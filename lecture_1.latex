\documentclass{article}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{blindtext}
\usepackage{multicol}
\usepackage{graphicx}
\usepackage{placeins}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{booktabs}
\usepackage{float}
\usepackage[bookmarks=true]{hyperref}
\usepackage{bookmark}
\usepackage{bbm}
\usepackage{wrapfig}
\usepackage[autostyle=true]{csquotes}
\graphicspath{ {./images/} }
\usepackage[bottom=0.5cm, right=1.5cm, left=1.5cm, top=1.5cm]{geometry}

\newtheorem{theorem}{Theorem}
\newtheorem{exercise}{Exercise}
\newtheorem{example}{Example}
\newtheorem{lemma}{Lemma}
\newtheorem{definition}{Definition}[section]

\newcommand{\R}{\ensuremath{\mathbb{R}}}
\newcommand{\N}{\ensuremath{\mathbb{N}}}
\newcommand{\Z}{\ensuremath{\mathbb{Z}}}
\newcommand{\p}{\ensuremath{\mathbb{P}}}
\newcommand{\E}{\ensuremath{\mathbb{E}}}
\newcommand{\M}{\ensuremath{\mathcal{M}}}
\newcommand{\C}{\ensuremath{\mathcal{C}}}
\newcommand{\K}{\ensuremath{\mathcal{K}}}
\newcommand{\1}{\ensuremath{\mathbbm{1}}}
\newcommand{\B}{\ensuremath{\mathbbm{B}}}

\title{Lecture 1}
\author{Gidon Rosalki}
\date{2025-10-22}


\begin{document}
\maketitle
\noindent\textbf{Notice:} If you find any mistakes, please open an issue at
\href{https://github.com/robomarvin1501/notes\_intro\_to\_crypto}{\texttt{https://github.com/robomarvin1501/notes\_intro\_to\_crypto}}

\section{Course overview}%
\label{sec:Course overview}
This is the second year of this format, before this it was the same name, but different format. 

\subsection{What is cryptography?}%
\label{sub:What is cryptography?}
Cryptography is an ancient art, that for many years focused mainly on secret communication. For as long as humans have
been communicating, we have wanted to be able to communicate in ways that hides the contents from people who are not
meant to know it. The main consumers were military, and intelligence. It generally relied on creativity, and personal
skill. From 500BC until the 20th century, there was a complete cycle of design $\to$ break $\to$ repair $\to$ break
$\to$ repair. We will focus on how one \textbf{breaks} this cycle. We will focus on modern cryptography, which underwent
a radical change in the 20th century, where it became a science, and covers much more than secret communication. It is
now consumed by everyone, and relies on rigorous models, definitions, and proofs. 

So, to answer our question: The scientific study of techniques for designing systems that withstand adversarial
behaviour.

\subsection{Course objectives}%
\label{sub:Course objectives}
We want to introduce the basic paradigms, principles of cryptography, and explore a variety of cryptographic tools
and systems. We will learn how to reason about their security, and how to use them correctly. By the end of this course
we will be educated crypto consumers, and know why it is dangerous to assume you are a \enquote{crypto expert} (spoiler,
you're really really not. Do not \textbf{ever} roll your own crypto), and be able to learn more about cryptography on
our own.

Tentative structure: \begin{enumerate}
    \item Weeks 1 - 5: Private key cryptography 
    \item Weeks 6 - 10: Public key cryptography 
    \item Weeks 11 - 13: Zero knowledge proofs and secret computation 
\end{enumerate}

We are recommended to read \begin{itemize}
    \item J. Katz, and Y. Lindell's \textit{Introduction to Modern Cryptography}   
    \item O. Goldreich \textit{Foundations of Cryptography - Volume 1: Basic tools} 
    \item O. Goldreich \textit{Foundations of Cryptography - Volume 2: Basic applications} 
    \item Coursera's \textit{\href{https://www.coursera.org/learn/cryptography}{Cryptography}} course by Professor Jonathan Katz 
\end{itemize} 

There will be somewhere between 3 and 5 homeworks, depending on how bothered the lecturer can be, and our final grade
will be made up of 10\% the $n - 1$ best homeworks, and 90\% final exam.

\section{Symmetric key encryption}%
\label{sec:Symmetric key encryption}
Let there be Alice, and Bob, located in different places, that want to communicate secretly. Eve will observe their
communications. Our assumption is that Alice, and Bob, share a secret key, that is not known to Eve. This key is used
for both encryption, and decryption. This key is some collection of bits, which may be used as described above. Let us
formalise these concepts: 
An encryption system includes three algorithms: \textit{KeyGen}, \textit{Enc}, \textit{Dec}. Let there be the key space
$\K$, plaintext / message space $\M$, and ciphertext space $\C$. 
\begin{itemize}
    \item The key generation algorithm KeyGen outputs a key $k \in \K$
    \item The encryption algorithm Enc takes a key $k \in \K$, and a plaintext $m \in \M$, and outputs a ciphertext $c \in
        \C$ 
    \item Decryption algorithm Dec takes a key $k \in \K$, and a ciphertext $c \in \C$, and outputs a plaintext $m \in \M$
\end{itemize}
\begin{align*}
    k \gets KeyGen() \\ 
    c \gets Enc_k \left(m\right) \\ 
    m = Dec_k \left(c\right)
\end{align*}
In this course $\gets$ indicates randomised generation, and $=$ indicates deterministic generation.

\subsection{Correctness}%
\label{sub:Correctness}
An encryption system is defined as correct if \[
    \forall k \in \K, m \in \M\ Dec_k \left(Enc_k \left(m\right)\right) = m
\]

Kerckhoff's principle: All of KeyGen, Enc, and Dec are publicly known, and the only secret is the key $k$. A crypto
system for whom the only security is the secrecy of the algorithms is not secure.

\subsection{Caesar Cipher}%
\label{sub:Caesar Cipher}
Let there be: \begin{itemize}
    \item KeyGen uniformly samples $k \gets \left\{0, \dots, 25\right\}$
    \item $M = \left\{a, \dots, z\right\}^l$ and $C = \left\{A, \dots, Z\right\}^l$
    \item Enc shifts each letter $k$ positions forward (wrapping around from z to a)
    \item Dec performs the same wrapping shift, but backwards
\end{itemize}

This is \textbf{not} a secure cipher (shocking, I know). Why? There are only 26 possible keys. An important part of good
ciphers is that $\left|K\right|$ must \textbf{not} allow an exhaustive search.

\subsection{Substitution cipher}%
\label{sub:Substitution cipher}
Let there be: \begin{itemize}
    \item KeyGen uniformly samples a permutation $k$ over $\left\{a, \dots, z\right\}$
    \item $M = \left\{a, \dots, z\right\}^l$ and $C = \left\{A, \dots, Z\right\}^l$
    \item Enc applies the permutation $k$ to each letter 
    \item Dec applies the inverse permutation $k^{-1}$
\end{itemize}
This is not secure either (shocking, I know). Despite there being many more keys ($26!$), this is particularly
susceptible to frequency analysis, where we use statistical patterns of the frequencies of different letters in the
source language.

\subsection{Vigenere cipher}%
\label{sub:Vigenere cipher}
Let there be: \begin{itemize}
    \item KeyGen uniformly samples $k = k_0 \dots k_{t - 1} \gets \left\{0, \dots, 25\right\}^t$  
    \item $M = \left\{a, \dots, z\right\}^l$ and $C = \left\{A, \dots, Z\right\}^l$
    \item Enc shifts the $i$th letter $k_{i \mod t}$ positions forward
    \item Dec applies the inverse shift
\end{itemize}
Not secure, it is trickier, but since the key is repeated, we can figure out the length of the key, and establish the
different parts of the key through frequency analysis once more.


\section{Historical ciphers}%
\label{sec:Historical ciphers}
There is a fascinating history of interesting, creative (and now broken) ideas. It was particularly influenced by world
history (e.g. the cryptanalysis of the German enigma in World War 2). Creating a crypto system is very very hard. Trying
to do so will probably result in one that is easily broken.

\section{Basic principles of modern cryptography}%
\label{sec:Basic principles of modern cryptography}
Analysing the security pf a cryptographic system involves: \begin{enumerate}
    \item Formalising a precise definition of security (security = computational ability $\times$ type of attack $\times$
        notion of \enquote{break} )
    \item Stating the underlying assumptions: Others will attempt to validate (or invalidate) your assumptions
    \item Proving that the definition is satisfied given the assumptions. Despite this, schemes can still be broken.
\end{enumerate}

There are a few attacks on encryption schemes: \begin{itemize}
    \item Known ciphertext attack: Eve may observe a challenge ciphertext $c^*$
    \item Known plaintext attack: Eve learns pairs $\left(m, Enc_k \left(m\right)\right)$, and then observes a challenge
        ciphertext $c^*$
    \item Chosen plaintext attack (CPA): Eve learns airs $\left(m, Enc_k \left(m\right)\right)$ for messages $m$ of her
        choice, then observes a challenge ciphertext $c^*$
    \item Chosen ciphertext attack: (CCA) Eve learns pairs $\left(m, Enc_k \left(m\right)\right)$, for messages $m$ of
        her choice, and pairs $\left(c, Dec_k \left(c\right)\right)$ for ciphertexts $c$ of her choice, and then
        observes a challenge ciphertext $c^* \ne c$
\end{itemize}

So, what does it mean to break an encryption scheme? Does it mean recovering the key? Recovering the plaintext?
Recovering part of the plaintext? Not really any of these. Breaking an encryption scheme means learning anything
\enquote{meaningful} about the plaintext? So, how do we define \enquote{meaningful}? We'll come back to that. \\ 
We shall characterise an adversary's computational abilities as follows: \begin{itemize}
    \item Typically (not always) run in probabilistic polynomial time (PPT)
    \item Sometimes, we will say computationally unbounded
\end{itemize}

\section{Perfect secrecy}%
\label{sec:Perfect secrecy}
Let (K:eyGen, Eng, Dec) be a symmetric key encryption scheme. Alice and Bob share a key $k \gets KeyGen()$. Eve knows an
a-priori distribution $M$. Informally, perfect secrecy is that the ciphertext $c$ does not reveal \textit{any}
information about the plaintext $m$.

\begin{definition}[Perfect secrecy]
    A symmetric key encryption scheme $\Pi = \left(KeyGen, Enc, Dec\right)$ is \textbf{perfectly secret} if for every
    distribution over $M$, and for every $m \in \M$, and for every $c \in \C$ it holds that \[
        Pr \left[M = m | C = c\right] = Pr \left[M = m\right]
    \]
    That is, the probability that some plaintext is the plaintext given the ciphertext, is the same as the probability
    that some plaintext is the plaintext, with no priors.
\end{definition}

Consider a die. If I throw a die, the probability of guessing its result is $\frac{1}{6} $. The encryption system is
perfect, if given an encrypted form of what number was thrown, the probability of knowing what number was thrown is
still $\frac{1}{6} $. \\ 

\begin{lemma}[]
    A symmetric key encryption scheme $\Pi$ is perfectly secret \textbf{if and only if} for every distribution over $M$,
    for every $m \in \M$, and for every $c \in \C$, it holds that \[
        Pr \left[C = c | M = m\right] = Pr \left[C = c\right]
    \]
    I.e. the probability of a specific message encoding to a specific ciphertext is the same for every message in the
    world.

    \begin{proof}[]
        Let there be a distribution over $M, m \in \M$, and $c \in \C$. Let us assume that \[
            Pr \left[C = c | M = m\right] = Pr \left[C = c\right]
        \]
        therefore \begin{align*}
            Pr \left[M = m | C = c\right] &= \frac{Pr \left[C = c | M = m\right] \cdot P \left[M = m\right]}{Pr \left[C
            = c\right]}  \\ 
            &= Pr \left[M = m\right]
        \end{align*}    
        The other direction is the exact same thing, uses bayes theorem, but swapping $M$ and $C$.
    \end{proof}
\end{lemma}

\begin{lemma}[]
    A symmetric key encryption scheme $\pi$ is perfectly secret \textbf{if and only if} for every distribution over
    $\mathcal{m}$, for every $m_0, m_1 \in \mathcal{m}$ and for every $c \in \mathcal{c}$ it holds that \[
        pr \left[c = c | m = m_0\right] = pr \left[c = c | m = m_1\right]
    \]

    \begin{proof}[]
        % todo 32 / 15:24 (one direction is in homework, check what the chap said in the lecture)
    \end{proof}
\end{lemma}

\begin{theorem}[]
    The shift and substitution ciphers are \textbf{not perfectly secret} for plaintexts of length $l > 1$.

    \begin{proof}[]
        Shift cipher: \[
            Pr \left[C = "AB" | M = "ab"\right] = \frac{1}{26} \ne 0 = Pr \left[C = "AB" | M = "aa"\right]
        \]
    \end{proof}
\end{theorem}

\section{One time pad}%
\label{sec:One time pad}
Created by Turing. \begin{itemize}
    \item $\K = \M = \C = \left\{0, 1\right\}^l$
    \item KeyGen uniformly samples $k \gets \left\{0, 1\right\}^l$
    \item $Enc_k \left(m\right) = m \oplus k$
    \item $Dec_k \left(c\right) = c \oplus k$
\end{itemize}
This is correct since: \begin{align*}
    \forall k \in \K,\ m \in \M\ Dec_k \left(Enc_k \left[m\right]\right) = Dec_k \left[m \oplus k\right] = m \oplus k \oplus k
    = m
\end{align*}

\begin{theorem}[Perfect secrecy]
    The one time pad is perfectly secret for plaintexts of any length $l$

    \begin{proof}[]
        Let us fix $m_0, m_1 \in \M$, and $c \in \C$. We will prove that \[
            Pr \left[C = c | M = m_0\right] = Pr \left[C = c | M = m_1\right]
        \]
        For each $b \in \left\{0, 1\right\}$ it holds that \begin{align*}
            Pr \left[C = c | M = m_b\right] &= Pr \left[M \oplus K = c | M = m_b\right] \\
                                            &= Pr \left[m_b \oplus K = c\right] \\
                                            &= Pr \left[K = c \oplus m_b\right] \\ 
                                            &= \frac{1}{2^l} 
        \end{align*}
        This is true for every $m_0, m_1$, and so is generalised, as is required.
    \end{proof}
\end{theorem}

\subsection{Limitations of the one time pad}%
\label{sub:Limitations of the one time pad}
Keys have to be as long as the plaintexts, and so are very long. Additionally, there is \enquote{Two time} insecurity.
Given $c = Enc_k \left(m\right)$ and $c' = Enc_k \left(m'\right)$, we can learn $c \oplus c' = m \oplus m'$. There is an
additional insecurity against known plaintext attacks. From $m$ and $c = Enc_k \left(m\right)$ we can recover $k = m
\oplus c$.

\begin{theorem}[]
    Let $\Pi$  be a symmetric encryption scheme, with key space $\K$, and message space $\M$. If $\Pi$ is perfectly
    secret, then $\left|\K\right| \geq \left|\M\right|$

    \begin{proof}[]
        Let us assume that $\left|\K\right| < \left|\M\right|$, and then we will show that the scheme is not perfectly
        secret. Let $M$ be the uniform distribution over $\M$, and fix some $m \in \M$. Let us also fix some $c \in \C$,
        which is a possible encryption of $m$. Let \[
            \M \left(c\right) \stackrel{def}{=} \left\{\hat{m} : \hat{m} = Dec_{\hat{k}} \left(c\right) \text{ for some
            } \hat{k} \in \K\right\}
        \]
        Then $\left|\M \left(c\right)\right| \leq \left|\K\right|$. Thus, the assumption that $\left|\K\right| <
        \left|\M\right|$ implies that $\left|\M \left(c\right)\right| < \left|\M\right|$. In particular, there exists
        some $m^* \in \M : m^* \notin \M \left(c\right)$. This implies that \[
            Pr \left[M = m^* : C = c\right] = 0 \ne \frac{1}{\left|\M\right|}  = Pr \left[M = m^*\right]
        \]
        and so the scheme is not perfectly secret.
    \end{proof}
\end{theorem}

\subsection{Characterising perfect secrecy}%
\label{sub:Characterising perfect secrecy}
\begin{theorem}[Shannon's theorem]
    Let $\Pi$ be a symmetric key encryption scheme for which $\left|\K\right| = \left|\M\right| = \left|\C\right|$.
    $\Pi$ is perfectly secret \textbf{if and only if} the following two conditions hold:
    \begin{enumerate}
        \item Every $k \in \K$ chosen by KeyGen is chosen with a probability of $\frac{1}{\left|\K\right|} $
        \item For every $m \in \M$, and $c \in \C$, there exists exactly one $k \in \K$ such that $Enc_k \left(m\right)$
            outputs $c$
    \end{enumerate}
\end{theorem}


\section{Tutorial}%
\label{sec:Tutorial}
Behold: Another definition of perfect secrecy:
\begin{exercise}[Perfect secrecy]
    For every encryption system $\Pi$, that has perfect secrecy: For every distribution $M$ on the plaintext space $\M$,
    and for every 2 ciphertexts $c_0, c_1 \in \C$, it is true that \[
        Pr \left[C = c_0\right] = Pr \left[C = c_1\right]
    \]

    \begin{proof}[Solution]
        This is incorrect. 
        Let \begin{gather*}
            KeyGen : k \gets \left\{0, 1\right\}^l \\ 
            \text{Let there be an additional bin } b = \begin{cases}
                0, &\text{ with probability }\frac{1}{3} \\
                1, &\text{ with probability }\frac{2}{3} \\
            \end{cases}
            Enc \left(k, m\right) : c = k \oplus m \| b \text{ here the double line indicates appending} \\
            Dec \left(c, k\right) : c' \oplus k = m \text{ where } c' = c \text{ without } b
        \end{gather*}
        So, as we can see here, it does not hold that $Pr \left[C = c_0\right] = Pr \left[C = c_1\right]$, since
        $\frac{2}{3} $rds of the ciphertexts will end with 1, and $\frac{1}{3} $ will end with 0.
    \end{proof}
\end{exercise}

\begin{exercise}
    Given $\Pi$ that has perfect secrecy, distribution $M$ on $\M$. Let there be 2 messages $m_0, m_1 \in \M$. For every
    $c \in \C$: 
    \[ 
        Pr \left[C = c | M = m_0\right] = Pr \left[C = c | M = m_1\right]
    \]
    \begin{proof}[Solution]
        Correct: By using Bayes law:
        \begin{align*}
            Pr \left[C = c | M = m_0\right] &= Pr \left[C = c\right] \\ 
            Pr \left[C = c | M = m_1\right] &= Pr \left[C = c\right]
        \end{align*}
        INCOMPLETE
        As required % TODO may be more left
    \end{proof}
\end{exercise}

\begin{exercise}
    Let us define $\hat{OTP}$, which is the same as OTP, but the keygen is defined as follows \[
        KeyGen: k \gets \left\{0, 1\right\}^l \setminus \left\{0^l\right\}
    \]
    Is this secure?
    \begin{proof}[Solution]
        No. Let there be $M \gets \left\{0, 1\right\}^l$, and so \[
            Pr \left[M = m | C = m\right] = 0 \ne \frac{1}{\left|M\right|} = Pr \left[M = m\right]
        \]
        when $M \gets \left\{0, 1\right\}^l$
    \end{proof}
\end{exercise}




\end{document}
