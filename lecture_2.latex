\documentclass{article}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{blindtext}
\usepackage{multicol}
\usepackage{graphicx}
\usepackage{placeins}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{booktabs}
\usepackage{float}
\usepackage[bookmarks=true]{hyperref}
\usepackage{bookmark}
\usepackage{bbm}
\usepackage{wrapfig}
\usepackage[autostyle=true]{csquotes}
\graphicspath{ {./images/} }
\usepackage[bottom=0.5cm, right=1.5cm, left=1.5cm, top=1.5cm]{geometry}

\newtheorem{theorem}{Theorem}
\newtheorem{exercise}{Exercise}
\newtheorem{example}{Example}
\newtheorem{definition}{Definition}[section]

\newcommand{\R}{\ensuremath{\mathbb{R}}}
\newcommand{\N}{\ensuremath{\mathbb{N}}}
\newcommand{\Z}{\ensuremath{\mathbb{Z}}}
\newcommand{\p}{\ensuremath{\mathbb{P}}}
\newcommand{\E}{\ensuremath{\mathbb{E}}}
\newcommand{\M}{\ensuremath{\mathcal{M}}}
\newcommand{\C}{\ensuremath{\mathcal{C}}}
\newcommand{\K}{\ensuremath{\mathcal{K}}}
\newcommand{\1}{\ensuremath{\mathbbm{1}}}
\newcommand{\B}{\ensuremath{\mathbbm{B}}}

\title{Lecture 2 - Private key encryption}
\author{Gidon Rosalki}
\date{2025-10-29}


\begin{document}
\maketitle
\section{Reminder}\label{sec:reminder} % (fold)
Last week we discussed symmetric encryption, and perfect secrecy: \[
    \p \left[M = m | C = c\right] = \p \left[M = m\right]
\]
which has the limitations of only considering security for a single message, and that the key must be as long as the
message.
% section Reminder (end)

\section{Computational security}\label{sec:computational_security} % (fold)
Computational security is that all the information is present, given $Enc_k \left(m\right)$ one may completely determine
$k$ and $m$. It should be \textbf{computationally infeasible} to retrieve any useful information. Here we have two
realistic relaxations compared to last week: \begin{enumerate}
    \item Security is preserved only against \textbf{computationally bounded} adversaries (e.g. 2000 years using
        currently technology)
    \item Allow such adversaries to succeed with some \textit{negligible} probability (small enough that it will
        essentially never happen)
\end{enumerate}

\subsection{Approaches}\label{sub:approaches} % (fold)
\subsubsection{Concrete approach}\label{sec:concrete_approach} % (fold)

\begin{definition}[]
    A scheme is $\left(t, \varepsilon\right)$-secure if every adversary, running for time at most $t$ succeeds in breaking
    the scheme with probability at most $\varepsilon$.
\end{definition}

We have some sample parameters of $t = 2^{60}$, which is the order of the number of seconds since the big bang, and
$\varepsilon = 2^{-60}$, which is order of occurring once every 100 billion years. \\
This is very useful in practice, and may be tailored to specific technology. However, in general we would like a notion
of security that is essentially independent of the underlying technology. 

% subsubsection Concrete approach (end)

\subsubsection{Asymptotic approach}\label{sec:asymptotic_approach} % (fold)
\begin{definition}[]
    A scheme is secure if every \textbf{probabilistic polynomial-time} (PPT) adversary succeeds in breaking the scheme
    with only \textbf{negligible} probability.
\end{definition}

\begin{definition}[PPT]
    An algorithm $A$ runs in \textbf{probabilistic polynomial-time} if there exists a polynomial $p \left(\cdot\right)$
    such that, for any input $x \in \left\{0, 1\right\}^*$, and a random tape $r \in \left\{0, 1\right\}^*$, the
    computation of $A \left(x; r\right)$ terminates within $p \left(\left|x\right|\right)$ steps
\end{definition}

The security parameter: \begin{itemize}
    \item KeyGen takes as input the security parameter $1^n$, and outputs $k \in \K_n$
    \item Keys produced by $KeyGen \left(1^n\right)$ should provide security against adversaries whose running time is
        polynomial in $n$ (so increasing $n$ provides better security)
    \item $\K = \displaystyle\bigcup_{n \in \N}^{}\K_n,\ \M =\displaystyle\bigcup_{n \in \N}^{}\M_n,\ \C =
        \displaystyle\bigcup_{n \in \N}^{}\C_n$
\end{itemize}

\begin{definition}[Negligible]
    A function $f: \N \to \R^+$ is \textbf{negligible} if for every polynomial $p \left(\cdot\right)$ there exists an
    $N$ such that $\forall n > N$, it holds that $f \left(n\right) < \displaystyle\frac{1}{p \left(n\right)}$
\end{definition}

For example, $2^{-n}, 2^{-\sqrt{n}}, 2^{-\log^2 \left(n\right)} $ are all negligible functions, where
$\displaystyle\frac{1}{2}, \displaystyle\frac{1}{\log^2 \left(n\right)}, \displaystyle\frac{1}{n^5}$ are non negligible.

\begin{theorem}[]
    Let $v_1 \left(n\right), v_2 \left(n\right)$ be negligible functions. Then, for any positive polynomial $p
    \left(n\right)$, the function $p \left(n\right) \cdot \left(v_1 \left(n\right) + v_2 \left(n\right)\right)$ is
    negligible.

    \begin{proof}[Proof ]
        A negligible function is $\displaystyle\frac{1}{\hat{p}}$, where $\hat{p}$ is larger than every polynomial. As a
        result, whatever we put in the numerator, will not impact our result. Therefore, the sum remains a negligible
        function. Multiplying by a polynomial is like writing $\displaystyle\frac{1}{\frac{\hat{p}}{p}}$,
        or subtracting in the powers: $n^{l - c}$, but since $l$ is asymptotically larger than all polynomials, we still
        have a negligible function.
    \end{proof}
\end{theorem}

So why these choices? \enquote{Efficient}: PPT, and \enquote{negligible}: smaller than any inverse polynomial. It is
intuitively well-behaved under composition: \[
    poly \left(n\right) \cdot poly \left(n\right) = poly \left(n\right)
\]
Polynomially many invocations of a PPT algorithm is still a PPT algorithm.
\[
    poly \left(n\right) \cdot negligible \left(n\right) = negligible \left(n\right)
\]
Polynomially many invocations of a PPT algorithm that succeeds with a negligible probability is an algorithm that
succeeds with a negligible probability overall. 
% subsubsection Asymptotic approach (end)
% subsection Approaches (end)

% section Computational security (end)

\section{Indistinguishable encryptions}\label{sec:indistinguishable_encryptions} % (fold)
The most basic notion of security for symmetric-key encryption: Encryptions of any two messages should be
indistinguishable. The adversary still observes only a single ciphertext. \[
    Enc_k \left(m_0\right) \approx Enc_k \left(m_1\right)
\]
This seems weaker compared to perfect secrecy. Perfectly-secure encryption reveals no information, so intuitively, what
security does indistinguishable encryptions provide?

Given $\Pi = \left(KeyGen, Enc, dec\right)$, and an adversary $\mathcal{A}$, consider the experiment $IND_{\Pi,
\mathcal{A}} \left(n\right)$, where one of two plaintexts $m_0, m_1$ is encrypted by the system,
and then $\mathcal{A}$ needs to figure out which plaintext it was from the returned ciphertext $c$. The system is
indistinguishable if $\mathcal{A}$ cannot do better than a coin flip.
\begin{definition}[Indistinguishable encryption]
    $\Pi$ has indistinguishable encryption if for every PPT adversary $\mathcal{A}$ there eixsts a negligible function
    $v \left(\cdot\right)$ such that \[
        \p \left[IND_{\Pi, \mathcal{A}} \left(n\right) = 1\right] \leq \displaystyle\frac{1}{2} + v \left(n\right)
    \]
    where the probability is taken over the random coins used by $\mathcal{A}$, and by the experiment.
\end{definition}

Recall the one time pad: \begin{itemize}
    \item $\K = \M = \C = \left\{0, 1\right\}^l$
    \item KeyGen uniformly samples $k \gets \left\{0, 1\right\}^l$
    \item $Enc_k \left(m\right) = m \oplus k$, and $Dec_k \left(c\right) = c \oplus k$
\end{itemize}
Perfectly secure since $\p \left[M = m | C = c\right] = \p \left[M = m\right]$, but requires the key $k$ to be as long
as the message $m$. Way too long. Can we guarantee computational security with shorter keys?
% section Indistinguishable encryptions (end)

\section{Pseudo-random generator}\label{sec:pseudo_random_generator} % (fold)
Our goal is to expand a short, random seed into a long \enquote{random looking} value: \[
    G: \left\{0, 1\right\}^l \to \left\{0, 1\right\}^l
\]
\enquote{Random looking} means \enquote{indistinguishable} from the uniform distribution.

\begin{definition}[PRG]
    Let $G: \left\{0, 1\right\}^l \to \left\{0, 1\right\}^l$ be a polynomial-time computable function, and let $l
    \left(\cdot\right)$ be a polynomial such that for any input $s \in \left\{0, 1\right\}^n$, we have $G \left(s\right)
    \in \left\{0, 1\right\}^{l \left(n\right)}$. Then, $G$ is a \textbf{pseudorandom generator} if the following two
    conditions hold: \begin{itemize}
        \item Expansion: $l \left(n\right) > n$
        \item Pseudorandomness: For every PPT \enquote{distinguisher} $\mathcal{D}$, there exists a negligible function
            $v \left(\cdot\right)$ such that \[
                \left|\p_{s \gets \left\{0, 1\right\}^n} \left[\mathcal{D} \left(G \left(s\right)\right) = 1\right] -
                \p_{r \gets \left\{0, 1\right\}^{l \left(n\right)}} \left[\mathcal{D} \left(r\right) = 1\right]\right|
                \leq v \left(n\right)
            \]
    \end{itemize}
\end{definition}
The notation $x \gets \left\{0, 1\right\}^m$ denotes that $x$ is sampled from the \textbf{uniform distribution} over
$\left\{0, 1\right\}^m$ (so each value is obtained with the probability $\displaystyle\frac{1}{2^m}$)

\subsection{Do PRGs even exist?}\label{sub:do_prgs_even_exist_} % (fold)
If so, then how difficult is it to construct a PRG? Recall two properties: \begin{itemize}
    \item Expansion: $\left|G \left(s\right)\right| > \left|s\right|$
    \item Pseudorandomness: For every PPT $\mathcal{D}$, there exists a negligible $v \left(\cdot\right)$ such that: \[
                \left|\p_{s \gets \left\{0, 1\right\}^n} \left[\mathcal{D} \left(G \left(s\right)\right) = 1\right] -
                \p_{r \gets \left\{0, 1\right\}^{l \left(n\right)}} \left[\mathcal{D} \left(r\right) = 1\right]\right|
                \leq v \left(n\right)
        \]
\end{itemize}

Let us try. Consider the following candidates that expand a seed $s = s_1 \dots s_n \in \left\{0, 1\right\}^n$ by a
single bit. Let us define \[
    G \left(s\right) = s0
\]
Is it distinguishable from a truly random string? Yes. A truly random string may finish in 1, whereas this may not. 

How about \[
    G \left(s\right) = s_1 \dots s_n s_1
\]
It is distinguishable, since we can just check if we begin with the same bit as with which we started. 

Finally: \[
    G \left(s\right) = s_1 \dots s_n z\ :\ z = s_1 \oplus \dots \oplus s_n
\]
This is also distinguishable, since we can just check if the final bit is the xor of the bits before it. 

The existence of any PRG implies $P \ne NP$. Constructions are known based on various computational assumptions. We have
not created a PRG that may be proven to be such, since that would then prove that $P \ne NP$.

\begin{theorem}[]
    Let there be $G: \left\{0, 1\right\}^n \to \left\{0, 1\right\}^{2n}$. There exists $\mathcal{D}$ (not
    computationally efficient) such that \[
        \p_{s \gets \left\{0, 1\right\}^n} \left[\mathcal{D} \left(G \left(s\right) = 1\right)\right] - \p_{r \gets
        \left\{0, 1\right\}^{2n}} \left[\mathcal{D} \left(r\right) = 1\right] > \displaystyle\frac{1}{2}
    \]
    \begin{proof}[Proof ]
        Where $\left|z\right| = 2n$, \begin{align*}
            D \left(z\right) = Im \left(G\right) = \left\{l \in \left\{0, 1\right\}^{2n} | \exists s\ |\ G
            \left(s\right) = l\right\}
        \end{align*}
        We are asking if it is true that $z \in Im \left(G\right)$. If so, we will return $1$, and otherwise $0$. This
        distinguisher works since \begin{gather*}
            \p \left[D \left(G \left(s\right)\right) = 1\right] = 1 \\
            \p \left[D \left(r\right) = 1\right] = \displaystyle\frac{\left|Im \left(G\right)\right|}{2^{2n}} \leq
            \displaystyle\frac{1}{2^n}
        \end{gather*}
    \end{proof}
\end{theorem}

Useful fact: All efficiently-testable statistical properties of the uniform distribution are preserved by the output of
any PRG. For example: If $G$ is a PRG, then there exists a negligible function $v \left(\cdot\right)$ such that \[
    \p_{s \gets \left\{0, 1\right\}^n} \left[\text{Fraction of 1s in } G \left(s <
    \displaystyle\frac{1}{4}\right)\right] \leq v \left(n\right)
\]
% subsection Do PRGs even exist? (end)
% section Pseudo-random generator (end)

\section{PRG-based OTP}\label{sec:prg_based_otp} % (fold)
Let us assume that there exists PRGs. Let $G$ be a PRG with expansion $l \left(n\right)$. $\K_n = \left\{0,
1\right\}^n$, but $\M_n = \C_n = \left\{0, 1\right\}^{l \left(n\right)}$. $KeyGen \left(1^n\right)$ samples $k \gets
\left\{0, 1\right\}^n$. $Enc_k \left(m\right) = m \oplus G \left(k\right)$, and $Dec_k \left(c\right) = c \oplus G
\left(k\right)$.

So, given $k$, we generate $G \left(k\right)$, where $\left|G \left(k\right)\right| > \left|k\right|$, and then $c = G
\left(k\right) \oplus m$.

\begin{theorem}[]
    If $G$ is a PRG, then the scheme has indistinguishable encryptions. 

    \begin{proof}[Proof ]
        It's not perfect, the key is smaller than the messages, and we proved that the key must be the same length as
        the messages. We shall prove by \textbf{reduction}: \begin{itemize}
            \item Given an adversary $\mathcal{A}$, for the encryption scheme, construct a distinguisher $\mathcal{D}$
                for the PRG 
            \item $\mathcal{D}$ internally emulates $\mathcal{A}$
            \item $\mathcal{D}$'s efficiency, and advantage are Polynomially related to $\mathcal{A}$'s
        \end{itemize}
        So in short, if $G$ is a PRG, then $\Pi$ has indistinguishable encryptions. We will prove by contradiction, by
        assuming that $\Pi$ is not IE, and therefore $G$ is not a PRG (but we know this to be false, and thus have a
        contradiction).

        Behold, the actual proof: Let us assume that there exists a PPT adversary $\mathcal{A}$ and a polynomial $pp
        \left(n\right)$ such that \[
            \p \left[IND_{\Pi, \mathcal{A}} \left(n\right) = 1 \right] \geq \displaystyle\frac{1}{2} +
            \displaystyle\frac{1}{p \left(n\right)}
        \]
        for infinitely many $n$s.

        We will show that there exists a PPT distinguisher $\mathcal{D}$ and a polynomial $q \left(n\right)$, such that
        \[
            \left|\p_{s \gets \left\{0, 1\right\}^n} \left[\mathcal{D} \left(G \left(s\right)\right) = 1\right] - \p_{r
                \gets \left\{0, 1\right\}^{l \left(n\right)}} \left[\mathcal{D} \left(r\right) = 1\right]\right| \geq
            \displaystyle\frac{1}{q \left(n\right)}
        \]
        for infinitely many $n$s. Or in short, if there exists the adversary, then we can use it to construct the
        distinguisher. \\ 
        The distinguisher $\mathcal{D}$, on input $z$ invokes $\mathcal{A}$, and obtains $\left(m_0, m_1\right)$. It
        samples $b \gets \left\{0, 1\right\}$, and let $b' = \mathcal{A} \left(z \oplus m_b\right)$. It then outputs
        $1$ \textbf{if and only if} $b' = b$. \\ 
        From here we get 2 cases: \begin{itemize}
            \item Case 1: $z \gets \left\{0, 1\right\}^{l \left(n\right)}$. $\mathcal{A}$'s view is independent of $b$,
                and so \[
                    \p_{z \gets \left\{0, 1\right\}^{l \left(n\right)}} \left[\mathcal{D} \left(z\right) = 1\right] =
                    \displaystyle\frac{1}{2}
                \]
            \item Case 2: $z = G \left(k\right)$, where $k \gets \left\{0, 1\right\}^n$. $\mathcal{A}$'s view is
                identical to the experiment $IND_{\Pi, \mathcal{A}}$ and so it is equivalent to trying to find if they
                are distinguishable:
                \[
                    \p_{k \gets \left\{0, 1\right\}^n} \left[\mathcal{D} \left(G \left(k\right)\right) = 1\right] = \p
                    \left[IND_{\Pi, \mathcal{A}} \left(n\right) = 1\right] \geq \displaystyle\frac{1}{2} +
                    \displaystyle\frac{1}{p \left(n\right)}
                \]
        \end{itemize}
        So overall we constructed a PPT distinguisher
        $\mathcal{D}$ such that \[
            \left|\p_{s \gets \left\{0, 1\right\}^n} \left[\mathcal{D} \left(G \left(s\right)\right) = 1\right] - \p_{r
                \gets \left\{0, 1\right\}^{l \left(n\right)}} \left[\mathcal{D} \left(r\right) = 1\right]\right| \geq
            \displaystyle\frac{1}{p \left(n\right)}
        \]
        which contradicts the theorem that $G$ is a PRG.
    \end{proof}
\end{theorem}

We have made significant progress, but we still have the problem that each key may only be used once.
% section PRG-based OTP (end)

\section{Indistinguishable encryptions revisited}\label{sec:indistinguishable_encryptions_revisited} % (fold)
So far, this has enabled it to be infeasible to distinguish between $Enc_k \left(m_0\right)$ and $Enc_k
\left(m_1\right)$, but can we learn information of $m$ from $Enc_k \left(m\right)$

\begin{theorem}[Toy theorem]
    Let $\Pi$ have indistinguishable encryptions. Then, for any PPT adversary $\mathcal{B}$, there exists a negligible
    function $v \left(\cdot\right)$ such that \[
        \p \left[\mathcal{B} \left(1^n, Enc_k \left(m\right)\right) = LSB \left(m\right)\right] \leq
        \displaystyle\frac{1}{2} + v \left(n\right)
    \]
    where $m \gets \left\{0, 1\right\}^{l \left(n\right)}$ is sampled uniformly
    \begin{proof}[Proof by reduction]
        Assume a contradiction that there exists a PPT adversary $\mathcal{B}$ and a polynomial $p \left(n\right)$ such
        that \[
            \p \left[\mathcal{B} \left(1^n, Enc_k \left(m\right)\right) = LSB \left(m\right)\right] \leq
            \displaystyle\frac{1}{2} + \displaystyle\frac{1}{p \left(n\right)}
        \]
        for infinitely many $n$s. We then show that there exists a PPT adversary $\mathcal{A}$ and a polynomial $q
        \left(n\right)$ such that \[
            \p \left[IND_{\Pi, \mathcal{A}} \left(n\right) = 1\right] > \displaystyle\frac{1}{2} +
            \displaystyle\frac{1}{q \left(n\right)}
        \]
        for infinitely many $n$s.


        Behold the proof: For each $\sigma \in \left\{0, 1\right\}$, let $I_\sigma \subset \left\{0, 1\right\}^l$ be the
        set of messages whose LSB is $\sigma$. We will create the adversary $\mathcal{A}$, which on input $1^n$ will
        sample $m_0 \gets I_0$, and $m_1 \gets I_1$ uniformly and independently. On input $c^*$, it will output $b' = B
        \left(1^n, c^*\right)$. In short, $\mathcal{A}$ creates 2 messages, receives the encrypted form of one of them,
        and gives it to $\mathcal{B}$. If $\mathcal{B}$ correctly assumes the LSB, then we win, if not, we fail. \begin{align*}
            \p \left[IND_{\Pi, \mathcal{A}} \left(n\right) = 1\right] &= \p \left[\mathcal{B} \left(1^n, Enc_k
            \left(m_b\right)\right) = b\right] \\ 
                                                                      &= \displaystyle\frac{1}{2} \p_{m_0 \gets I_0}
                                                                      \left[\mathcal{B} \left(1^n, Enc_k
                                                                      \left(m_0\right)\right) = 0\right] + \displaystyle\frac{1}{2} \p_{m_1 \gets I_1}
                                                                      \left[\mathcal{B} \left(1^n, Enc_k
                                                                      \left(m_1\right)\right) = 1\right] \\ 
                                                                      &= \p_{m \gets \left\{0, 1\right\}^l}
                                                                      \left[\mathcal{B} \left(1^n, Enc_k
                                                                      \left(m\right)\right) = LSB(m)\right] \geq
                                                                      \displaystyle\frac{1}{2} + \displaystyle\frac{1}{p
                                                                      \left(n\right)}
        \end{align*}
    \end{proof}
\end{theorem}

\subsection{Semantic security}\label{sub:semantic_security} % (fold)
Goldwasser-Micali in 1982: \enquote{Whatever}  can be computed efficiently, given the ciphertext, can essentially be
computed efficiently without the ciphertext.

\begin{definition}[Semantically secure]
    $\Pi$ is \textbf{semantically secure} if for every adversary $\mathcal{A}$ there exists a PPT \enquote{simulator}
    $\mathcal{S}$ such that for every efficiently sampleable plaintext distribution $M = \left\{M_n\right\}_{n \in \N}$,
    and all polynomial-time computable functions $f$ and $h$, there exists a negligible function $v \left(\cdot\right)$
    such that \[
        \left|\p \left[\mathcal{A} \left(1^n, Enc_k \left(m\right), h \left(m\right)\right) = f \left(m\right)\right] -
        \p \left[\mathcal{S} \left(1^n, h \left(m\right)\right) = f \left(m\right)\right]\right| \leq v \left(n\right)
    \]
    where $k \gets KeyGen \left(1^n\right)$ and $m \gets M_n$
\end{definition}
Or in other words, whatever you can learn from the encryption, can also be efficiently learnt \textit{without} the
encryption, or most simply, the ciphertext teaches us \textbf{nothing}.

\begin{theorem}[]
    $\Pi$ is \textbf{semantically secure} \textbf{if and only if} it has \textbf{indistinguishable encryption}
\end{theorem}

Why do we need both notions? Well, semantic security explains \enquote{what security means}, where indistinguishability
of encryption is \enquote{easier with which to work}. Since they are equivalent, we can use IE, to show semantic
security.
% subsection Semantic security (end)

\subsection{One way functions}\label{sub:one_way_functions} % (fold)
\begin{definition}[]
    A \textit{polynomial-time} computable function $f: \left\{0, 1\right\}^* \to \left\{0, 1\right\}^*$ is \textbf{one
    way} if for any PPT $A$ \[
        \p_{y \gets f \left(U_n\right)} \left[A \left(1^n, y\right) \in f^{-1} \left(y\right)\right] \leq negligible \left(y\right)
    \]
\end{definition}
In short, easy to compute, but hard to invert on a random image. 

Informal theorem: One way functions are the basis for foundational cryptography. They are \textbf{complete} for private
key cryptography (PRG $\Leftrightarrow$ OWF, as in, one can make PRGs from one way functions, and vice versa)
% subsection One way functions (end)
% section Indistinguishable encryptions revisited (end)

Some recommended reading: J. Katz and Y. Lindell. Introduction to Modern Cryptography.
Chapter 3 (Private-Key Encryption): 3.0 â€“ 3.3
\end{document}
