\documentclass[a4paper]{article}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{blindtext}
\usepackage{multicol}
\usepackage{graphicx}
\usepackage{placeins}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{booktabs}
\usepackage{float}
\usepackage[bookmarks=true]{hyperref}
\usepackage{bookmark}
\usepackage{bbm}
\usepackage{wrapfig}
\usepackage{tabularx}
\usepackage{tikz}
\usetikzlibrary{automata, positioning, arrows, arrows.meta, calc}
\usepackage[autostyle=true]{csquotes}
\graphicspath{ {./images/} }
\usepackage[bottom=0.5cm, right=1.5cm, left=1.5cm, top=1.5cm]{geometry}

\newtheorem{theorem}{Theorem}
\newtheorem{exercise}{Exercise}
\newtheorem{example}{Example}
\newtheorem{definition}{Definition}[section]

\newcommand{\R}{\ensuremath{\mathbb{R}}}
\newcommand{\N}{\ensuremath{\mathbb{N}}}
\newcommand{\Z}{\ensuremath{\mathbb{Z}}}
\newcommand{\p}{\ensuremath{\mathbb{P}}}
\newcommand{\E}{\ensuremath{\mathbb{E}}}
\newcommand{\F}{\ensuremath{\mathcal{F}}}
\newcommand{\1}{\ensuremath{\mathbbm{1}}}
\newcommand{\B}{\ensuremath{\mathbbm{B}}}

\title{Game sheet}
\author{Gidon Rosalki}


\begin{document}
\maketitle
\noindent\textbf{Notice:} If you find any mistakes, please open an issue at \href{https://github.com/robomarvin1501/notes\_intro\_to\_crypto}{\texttt{https://github.com/robomarvin1501/notes\_intro\_to\_crypto}}

\section{Perfect secrecy}\label{sec:perfect_secrecry} % (fold)
\begin{definition}[Perfect secrecy]
    A symmetric key encryption scheme $\Pi = \left(\text{KeyGen}, \text{Enc}, \text{Dec}\right)$ is \textbf{perfectly
    secret} if for every distribution over $\mathcal{M}$, and for every $m \in \mathcal{M}$, and for every $c \in
    \mathcal{C}$ it holds that \[
        Pr \left[M = m | C = c\right] = Pr \left[M = m\right]
    \]
\end{definition}
That is, the probability that some plaintext is the plaintext given the ciphertext, is the same as the probability
that some plaintext is the plaintext, with no priors whatsoever.
% section Perfect secrecry (end)

\section{Indistinguishable encryption}\label{sec:indistinguishable_encryption} % (fold)
\begin{definition}[Indistinguishable encryption]
    $\Pi$ has \textbf{indistinguishable encryptions} if for every PPT adversary $\mathcal{A}$ there exists a negligible
    function $v \left(\cdot\right)$ such that \[
        \p \left[\text{IND}_{\Pi, \mathcal{A}} \left(n\right) = 1\right] \leq \displaystyle\frac{1}{2} + v \left(n\right)
    \]
    where the probability is taken over the random coins used by $\mathcal{A}$, and by the experiment.
\end{definition}

\begin{center}
    \begin{tikzpicture}[thick]
        \draw (0, 0) rectangle (4,5) node[pos=0.5] {\huge $\mathcal{A} \left(1 ^ {n}\right)$};

        \draw (9, 4.8) node {$k \gets \text{KeyGen} \left(1 ^ {n}\right)$};
        \draw[->,very thick] (4.2, 3.8) -- (7.2, 3.8) node [above,align=center,midway,text width=3cm] {$m_0, m_1$};

        \draw (9, 3.3) node {$b \gets \left\{0, 1\right\}$};
        \draw (9, 2.6) node {$c^* \gets \text{Enc}_k \left(m_b\right)$};

        \draw[<-,very thick] (4.2, 2.0) -- (7.2, 2.0) node [above,align=center,midway,text width=3cm] {$c^*$};

        \draw[->,very thick] (4.2, 0.8) -- (7.2, 0.8) node [above,align=center,midway,text width=3cm] {$b'$};
    \end{tikzpicture}
    \[
        \text{IND}_{\Pi, \mathcal{A}} \left(n\right) = \begin{cases}
            1, &\text{ if }b' = b\\
            0, &\text{ otherwise}\\
        \end{cases}
    \]
\end{center}

% section Indistinguishable encryption (end)

\section{PRGs}\label{sec:prgs} % (fold)
\begin{definition}[PRG]
    Let $G: \left\{0, 1\right\}^n \to \left\{0, 1\right\}^{l \left(n\right)}$ be a polynomial-time computable function,
    and let $l \left(\cdot\right)$ be a polynomial such that for any input $s \in \left\{0, 1\right\}^n$, we have $G
    \left(s\right) \in \left\{0, 1\right\}^{l \left(n\right)}$. Then, $G$ is a \textbf{pseudorandom generator} if the
    following two conditions hold: \begin{itemize}
        \item Expansion: $l \left(n\right) > n$
        \item Pseudorandomness: For every PPT \enquote{distinguisher} $\mathcal{D}$, there exists a negligible function
            $v \left(\cdot\right)$ such that \[
                \left|\Pr_{s \gets \left\{0, 1\right\}^n} \left[\mathcal{D} \left(G \left(s\right)\right) = 1\right] -
                \Pr_{r \gets \left\{0, 1\right\}^{l \left(n\right)}} \left[\mathcal{D} \left(r\right) = 1\right]\right|
                \leq v \left(n\right)
            \]
    \end{itemize}
\end{definition}
So, the probability that the distinguisher may tell the difference between the output of the PRG, and truly random
noise, is less than the output of the negligible function for that length of input.
% section PRGs (end)

\section{Semantic security}\label{sub:semantic_security} % (fold)
\begin{definition}[Semantically secure]
    $\Pi$ is \textbf{semantically secure} if for every adversary $\mathcal{A}$ there exists a PPT \enquote{simulator}
    $\mathcal{S}$ such that for every efficiently sampleable plaintext distribution $M = \left\{M_n\right\}_{n \in \N}$,
    and all polynomial-time computable functions $f$ and $h$, there exists a negligible function $v \left(\cdot\right)$
    such that \[
        \left|\Pr \left[\mathcal{A} \left(1^n, \text{Enc}_k \left(m\right), h \left(m\right)\right) = f
        \left(m\right)\right] - \Pr \left[\mathcal{S} \left(1^n, h \left(m\right)\right) = f
        \left(m\right)\right]\right| \leq v \left(n\right)
    \]
    where $k \gets KeyGen \left(1^n\right)$ and $m \gets M_n$
\end{definition}
Or in other words, whatever you can learn from the encryption, can also be efficiently learnt \textit{without} the
encryption, or most simply, the ciphertext teaches us \textbf{nothing}. $\Pi$ is \textit{semantically secure} \textbf{if
and only if} it has \textit{indistinguishable encryption}.
% section Semantic security (end)

\section{One way functions}\label{sec:one_way_functions} % (fold)
\begin{definition}[]
    A polynomial-time computable function $f: \left\{0, 1\right\}^* \to \left\{0, 1\right\}^*$ is \textbf{one
    way} if for any PPT $\mathcal{A}$, and negligible function $v \left(\cdot\right)$ \[
        \Pr_{y \gets f \left(U_n\right)} \left[\mathcal{A} \left(1^n, y\right) \in f^{-1} \left(y\right)\right] \leq v
        \left(y\right)
    \]
\end{definition}
Easy to compute, hard to invert.
% section One way functions (end)

\section{Computational Indistinguishability}\label{sec:computational_indistinguishability} % (fold)
\begin{definition}[Computationally indistinguishable]
    Two probability distributions $X = \left\{X_n\right\}_{n \in \N}$ and $Y = \left\{Y_n\right\}_{n \in \N}$ are
    \textbf{computationally indistinguishable} if for every PPT distinguisher $D$ there exists a negligible function $v
    \left(\cdot\right)$ such that \[
        \left|\Pr_{x \gets X_n} \left[D \left(1^n, x\right) = 1\right] - \Pr_{y \gets Y_n} \left[D \left(1^n, y\right) =
        1\right]\right| \leq v \left(n\right)
    \]
\end{definition}
This is denoted $X \approx ^ {c} Y$
% section Computational Indistinguishability (end)

\section{Hybrid argument}\label{sec:hybrid_argument} % (fold)
This is a complicated technique, so we shall present an example. \\ 
\begin{theorem}[]
    Let $G: \left\{0, 1\right\}^n \to \left\{0, 1\right\}^{4n}$ be a PRG, then $H \left(s_1, s_2\right) = G
    \left(s_1\right) || G \left(s_2\right)$ is a PRG. 

    \begin{proof}[Proof ]
        Our paradigm for this kind of proof is \textit{reduction} via a \textit{hybrid argument}. \\ 
        \textbf{Reduction}: Given a distinguisher $D$, for $H$, construct a distinguisher $A$ for $G$. \\ 
        \textbf{Hybrid argument}: Let us suppose that between $G \left(s_1\right), G \left(s_2\right)$ $D$ has
        advantage $\varepsilon$. Let us create a new PRG, that given $s_1, s_2$, ignores $s_2$, and returns $G
        \left(s_1\right), r_2$. So, between $G \left(s_1\right), G \left(s_2\right)$ and $G \left(s_1\right), r_2$, it
        holds that $D$ has at least the advantage $\displaystyle\frac{\varepsilon}{2}$, or between $G \left(s_1\right),
        r_2$ and $r_1, r_2$ it holds that $D$ has the advantage of at least $\displaystyle\frac{\varepsilon}{2}$. 

        \begin{center}
            \begin{tikzpicture}
                \draw (0, 0) rectangle (2, 1) node[pos=0.5] {$r_1$};
                \draw (2, 0) rectangle (4, 1) node[pos=0.5] {$r_2$};

                \draw[->,very thick] (-1, 1.865) node [left,align=center,text width=3cm] {Suppose that $\mathcal{D}$ has an advantage of $\varepsilon$}
                    -- (0, 0.565) ;
                \draw[->,very thick] (-1, 1.865) -- (0, 3.165) ;

                \draw (0, 1.3) rectangle (2, 2.3) node[pos=0.5] {$G \left(s_1\right)$};
                \draw (2, 1.3) rectangle (4, 2.3) node[pos=0.5] {$r_2$};

                \draw (0, 2.6) rectangle (2, 3.6) node[pos=0.5] {$G \left(s_1\right)$};
                \draw (2, 2.6) rectangle (4, 3.6) node[pos=0.5] {$G \left(s_2\right)$};

                \draw[->,very thick] (5, 1.215)
                                 --  (4, 0.565) ;
                \draw[->,very thick] (5, 1.215) node [right,align=center,text width=3cm] {Or here}
                                 --  (4, 1.765) ;

                \draw[->,very thick] (5, 2.515) 
                                 --  (4, 1.965) ;
                \draw[->,very thick] (5, 2.515) node [right,align=center,text width=3cm] {$\mathcal{D}$ must
                    have an advantage of $\frac{\varepsilon}{2}$ here}
                                 --  (4, 3.165) ;
            \end{tikzpicture}
        \end{center}

        So:
        \begin{align*}
            \varepsilon &\leq \left|\p \left[D \left(G \left(s_1\right) || G \left(s_2\right)\right) = 1\right] - \p
            \left[D \left(r_1 || r_2\right) = 1\right]\right| \\ 
                        &\leq \left|\p \left[D \left(G \left(s_1\right) || G \left(s_2\right)\right) = 1\right] - \p
                        \left[D \left(G \left(s_1\right) || r_2\right) = 1\right]\right| + \left|\p \left[D \left(G
                        \left(s_1\right) || r_2\right) = 1\right] - \p \left[D \left(r_1 || r_2\right) = 1\right]\right|
        \end{align*}

        Let us define $A$, which on input $z \in \left\{0, 1\right\}^{4n}$ with sample $s_1 \gets \left\{0,
        1\right\}^{n}$ and output $D \left(G \left(s_1\right) \| z\right)$. In this case, we have created an adversary
        that distinguishes between the first 2 cases based off the difference of $G \left(s_2\right)$ and $r_2$. We may
        similarly create a second adversary that performs the same, and outputs $D \left(Z \| r_2\right)$. Since
        \textit{one} of these transitions must be distinguishable with an advantage of at least
        $\frac{\varepsilon}{2}$, we have found an adversary $A$ for $G$, which is a contradiction to the
        given that $G$ is a PRG.
    \end{proof}
\end{theorem}
% section Hybrid argument (end)

\section{Chosen Plaintext Attack (CPA)}\label{sec:chosen_plaintext_attack_cpa_} % (fold)
We can modify Indistinguishable Encryption such that $\mathcal{A}$ may request any number of encryptions (From an
oracle), before it hands over the two messages between which it must distinguish: 

\begin{definition}[IND-CPA]
    $\Pi$ has indistinguishable encryptions under a chosen-plaintext attack if for every PPT adversary $\mathcal{A}$
    there exists a negligible function $v \left(\cdot\right)$ such that \[
        \Pr \left[\text{IND}_{\Pi, \mathcal{A}}^{\text{CPA}} \left(n\right) = 1\right] \leq \displaystyle\frac{1}{2} + v \left(n\right)
    \]
\end{definition}
This is to say, that the probability of winning the CPA game (described below) is 50\%, plus negligible.

\begin{center}
    \begin{tikzpicture}[
        thick,
        >=stealth,
        every node/.style={align=center},
        msg/.style={text width=3cm, above},
        block arrow/.style={->, very thick},
        loop/.style={out=30, in=-30, distance=1.2cm}
    ]
        % Define vertical spacing
        \def\dy{1.0} % Vertical step between message pairs
        
        % Adversary box
        \draw (0,0) rectangle (4,8) node[pos=0.5] {\huge $\mathcal{A} \left(1 ^ {n}\right)$};
        
        % Right column x-position
        \def\xright{9}
        % Middle column (between box and right)
        \def\xmid{5.7}
        \def\xmidtwo{7.2}
        \def\gameedge{4.2}
        
        % === First phase: Key generation ===
        \node at (\xright - 1, 7.8) {$k \gets \text{KeyGen}(1^n)$};

        % Query/Response loop above challenge (first instance)
        \begin{scope}[xshift=0.2cm,yshift=6.8cm]
            \coordinate (A-out) at (3.7, 0);
            \coordinate (mid-out) at (\xmid, 0);
            \coordinate (A-in) at (3.7, -\dy);
            \coordinate (mid-in) at (\xmid, -\dy);

            \draw[block arrow] (A-out) -- (mid-out) node [msg, midway] {$m$};
            \draw[block arrow] (mid-in) -- (A-in) node [msg, midway] {$\text{Enc}_k(m)$};
            \draw[block arrow] (mid-out) to [bend left] (mid-in);
            \draw[block arrow] (A-in) to [bend left] (A-out);
        \end{scope}

        % === Challenge phase ===
        \begin{scope}[yshift=4.9cm] % Adjust this to flow after first oracle loop
            % Right column node
            \node at (\xright, -0.2 * \dy) {$b \gets \{0, 1\}$};
            \node at (\xright, -0.8 * \dy) {$c^* \gets \text{Enc}_k(m_b)$};

            % Left and middle x positions
            \coordinate (challenge-out) at (\gameedge, 0);
            \coordinate (challenge-mid-out) at (\xmidtwo, 0);
            \coordinate (challenge-in) at (\gameedge, -\dy);
            \coordinate (challenge-mid-in) at (\xmidtwo, -\dy);

            % Arrows
            \draw[block arrow] (challenge-out) -- (challenge-mid-out) 
                node [msg, midway] {$m_0, m_1$};
            \draw[block arrow] (challenge-mid-in) -- (challenge-in) 
                node [msg, midway] {$c^*$};
        \end{scope}

        % === Second query/response phase (after challenge) ===
        \begin{scope}[xshift=0.2cm,yshift=2.8cm] % Adjusted to sit below challenge
            \coordinate (A-out) at (3.7, 0);
            \coordinate (mid-out) at (\xmid, 0);
            \coordinate (A-in) at (3.7, -\dy);
            \coordinate (mid-in) at (\xmid, -\dy);

            \draw[block arrow] (A-out) -- (mid-out) node [msg, midway] {$m$};
            \draw[block arrow] (mid-in) -- (A-in) node [msg, midway] {$\text{Enc}_k(m)$};
            \draw[block arrow] (mid-out) to [bend left] (mid-in);
            \draw[block arrow] (A-in) to [bend left] (A-out);
        \end{scope}

        % === Final guess ===
        \def\outputheight{0.8}
        \draw[block arrow] (\gameedge, \outputheight) -- (\xmidtwo, \outputheight) node [msg, midway] {$b'$};
    \end{tikzpicture}
    \begin{gather}
        \text{IND}_{\Pi, \mathcal{A}} ^ {\text{CPA}} \left(n\right) = \begin{cases}
            1, &\text{ if }b' = b\\
            0, &\text{ otherwise}\\
        \end{cases} 
    \end{gather}
\end{center}
% section Chosen Plaintext Attack (CPA) (end)

\section{Pseudorandom Functions}\label{sec:pseudorandom_function} % (fold)
\begin{definition}[PRF]
    An efficiently computable keyed function \[
        F: \left\{0, 1\right\}^n \times \left\{0, 1\right\}^n \to \left\{0, 1\right\}^{l \left(n\right)}
    \]
    is \textbf{pseudorandom} if for every PPT distinguisher $\mathcal{D}$ there exists a negligible function $v
    \left(\cdot\right)$ such that \[
        \left|\Pr \left[\mathcal{D}^{F_k \left(\cdot\right)} \left(1^n\right) = 1\right] - \Pr \left[\mathcal{D}^{h
        \left(\cdot\right)} \left(1^n\right) = 1\right]\right| \leq v \left(n\right)
    \]
    where $k \gets \left\{0, 1\right\}^n$ and $h \gets Func_{n \to l}$
\end{definition}

The methodology for using PRFs is as follows: \begin{enumerate}
    \item Prove security assuming a truly random function is used 
    \item Prove that if an adversary can break the scheme when PRF is used, then it can be used to distinguish the PRF
        from a truly random function
\end{enumerate}

We may consider Enc to be, for example something that returns $\left(r, \mathcal{O} \left(r\right) \oplus m_b\right)$,
and thus try and show if this is a CPA secure scheme or not. For example, for the theorem \textit{If $F$ is a PRF, then
$\Pi_F$ is CPA-Secure}. For the truly random function $h$, $\Pi_h$ is secure, so we may show that $\Pi_h$ is
indistinguishable from $\Pi_F$, by contradiction that finds that $\Pi_F$ is not a PRF. 

\begin{center}
    \begin{tikzpicture}[
        thick,
        >=stealth,
        every node/.style={align=center},
        msg/.style={text width=3cm, above},
        block arrow/.style={->, very thick},
        loop/.style={out=30, in=-30, distance=1.2cm}
    ]
        % Define vertical spacing
        \def\dy{1.0} % Vertical step between message pairs

        % Distinguisher box
        \draw (0, 0) rectangle (15, 11);
        \node at (0, 11) [anchor=north west, inner sep=1cm] {\huge $\mathcal{D} ^ {\mathcal{O}}$};
        
        % Adversary box
        \draw (4,2) rectangle (8,10) node[pos=0.5] {\huge $\mathcal{A} \left(1 ^ {n}\right)$};
        
        \begin{scope}[xshift=4cm,yshift=2cm]
            % Right column x-position
            \def\xright{9}
            % Middle column (between box and right)
            \def\xmid{5.7}
            \def\xmidtwo{7.2}
            \def\gameedge{4.2}
            
            % === First phase: Key generation ===
            \node at (\xright - 1, 7.8) {$k \gets \text{KeyGen}(1^n)$};

            % Query/Response loop above challenge (first instance)
            \begin{scope}[xshift=0.2cm,yshift=6.8cm]
                \coordinate (A-out) at (3.7, 0);
                \coordinate (mid-out) at (\xmid, 0);
                \coordinate (A-in) at (3.7, -\dy);
                \coordinate (mid-in) at (\xmid, -\dy);

                \draw[block arrow] (A-out) -- (mid-out) node [msg, midway] {$m$};
                \draw[block arrow] (mid-in) -- (A-in) node [msg, midway] {$\text{Enc}_k(m)$};
                \draw[block arrow] (mid-out) to [bend left] (mid-in);
                \draw[block arrow] (A-in) to [bend left] (A-out);
            \end{scope}

            % === Challenge phase ===
            \begin{scope}[yshift=4.9cm] % Adjust this to flow after first oracle loop
                % Right column node
                \node at (\xright, -0.2 * \dy) {$b \gets \{0, 1\}$};
                \node at (\xright, -0.8 * \dy) {$c^* \gets \text{Enc}_k(m_b)$};

                % Left and middle x positions
                \coordinate (challenge-out) at (\gameedge, 0);
                \coordinate (challenge-mid-out) at (\xmidtwo, 0);
                \coordinate (challenge-in) at (\gameedge, -\dy);
                \coordinate (challenge-mid-in) at (\xmidtwo, -\dy);

                % Arrows
                \draw[block arrow] (challenge-out) -- (challenge-mid-out) 
                    node [msg, midway] {$m_0, m_1$};
                \draw[block arrow] (challenge-mid-in) -- (challenge-in) 
                    node [msg, midway] {$c^*$};
            \end{scope}

            % === Second query/response phase (after challenge) ===
            \begin{scope}[xshift=0.2cm,yshift=2.8cm] % Adjusted to sit below challenge
                \coordinate (A-out) at (3.7, 0);
                \coordinate (mid-out) at (\xmid, 0);
                \coordinate (A-in) at (3.7, -\dy);
                \coordinate (mid-in) at (\xmid, -\dy);

                \draw[block arrow] (A-out) -- (mid-out) node [msg, midway] {$m$};
                \draw[block arrow] (mid-in) -- (A-in) node [msg, midway] {$\text{Enc}_k(m)$};
                \draw[block arrow] (mid-out) to [bend left] (mid-in);
                \draw[block arrow] (A-in) to [bend left] (A-out);
            \end{scope}

            % === Final guess ===
            \def\outputheight{0.8}
            \draw[block arrow] (\gameedge, \outputheight) -- (\xmidtwo, \outputheight) node [msg, midway] {$b'$};
                
        \end{scope}

        \draw[block arrow] (15.5, 6) -- (19, 6) node [msg, midway] {0 or 1};
    \end{tikzpicture}
    \begin{gather}
        \text{IND}_{\Pi, \mathcal{A}} ^ {\text{CPA}} \left(n\right) = \begin{cases}
            1, &\text{ if }b' = b\\
            0, &\text{ otherwise}\\
        \end{cases} 
    \end{gather}
\end{center}
% section Pseudorandom Function (end)

\section{MACs}\label{sec:macs} % (fold)
\begin{definition}[MAC scheme]
    A MAC (Message Authentication Code) scheme $\Pi = \left(Gen, Mac, \text{Vrfy}\right)$ is secure if for every PPT
    adversary $\mathcal{A}$, there exists a negligible function $v \left(\cdot\right)$ such that \[
        \Pr \left[MacForge_{\Pi, \mathcal{A}} \left(n\right) = 1\right] \leq v \left(n\right)
    \]
\end{definition}
This is to say, it is very hard for a PPT adversary to create a new message, with a correct MAC.

\begin{center}
    \begin{tikzpicture}[
        thick,
        >=stealth,
        every node/.style={align=center},
        msg/.style={text width=3cm, above},
        block arrow/.style={->, very thick},
        loop/.style={out=30, in=-30, distance=1.2cm}
    ]
        % Define vertical spacing
        \def\dy{1.0} % Vertical step between message pairs
        
        % Adversary box
        \draw (0,0) rectangle (4,4) node[pos=0.5] {\huge $\mathcal{A}$};
        
        % Right column x-position
        \def\xright{9}
        % Middle column (between box and right)
        \def\xmid{5.7}
        \def\xmidtwo{7.2}
        \def\gameedge{4.2}
        
        % === First phase: Key generation ===
        \node at (\xright - 1, 3.8) {$k \gets \text{KeyGen}(1^n)$};

        % Query/Response loop above challenge (first instance)
        \begin{scope}[xshift=0.2cm,yshift=3.2cm]
            \coordinate (A-out) at (3.7, 0);
            \coordinate (mid-out) at (\xmid, 0);
            \coordinate (A-in) at (3.7, -\dy);
            \coordinate (mid-in) at (\xmid, -\dy);

            \draw[block arrow] (A-out) -- (mid-out) node [msg, midway] {$m$};
            \draw[block arrow] (mid-in) -- (A-in) node [msg, midway] {$\text{Mac}_k \left(m\right)$};
            \draw[block arrow] (mid-out) to [bend left] (mid-in);
            \draw[block arrow] (A-in) to [bend left] (A-out);
        \end{scope}

        % === Final output ===
        \def\outputheight{0.8}
        \draw[block arrow] (\gameedge, \outputheight) -- (\xmidtwo, \outputheight) node [msg, midway] {$\left(m^*, t^*\right)$};
    \end{tikzpicture}
    \begin{gather}
        \text{Let }\mathcal{Q} = \text{ the set of all queries asked by } \mathcal{A} \\
        \text{MacForge}_{\Pi, \mathcal{A}} \left(n\right)= \begin{cases}
            1, &\text{ if }\text{Vrfy}_k \left(m^*, t^*\right) = 1 \land m^* \notin \mathcal{Q}\\
            0, &\text{ otherwise}
        \end{cases}
    \end{gather}
    Note that this does \textbf{not} prevent replay attacks!
\end{center}
% section MACs (end)

\pagebreak
\section{CRHF}\label{sec:crhf} % (fold)
\begin{definition}[Collision Resistant]
    $\Phi$ is \textbf{collision resistant} if for every PPT adversary $\mathcal{A}$ there exists a negligible function
    $v \left(\cdot\right)$ such that \[
        \Pr \left[HashColl_{\Phi, \mathcal{A}} \left(n\right) = 1\right] \leq v \left(n\right)
    \]
\end{definition}
We may describe HashColl as follows: 

\begin{center}
    \begin{tikzpicture}[
        thick,
        >=stealth,
        every node/.style={align=center},
        msg/.style={text width=3cm, above},
        block arrow/.style={->, very thick},
        loop/.style={out=30, in=-30, distance=1.2cm}
    ]
        % Define vertical spacing
        \def\dy{1.0} % Vertical step between message pairs
        
        % Adversary box
        \draw (0,0) rectangle (4,4) node[pos=0.5] {\huge $\mathcal{A}$};
        
        % Right column x-position
        \def\xright{9}
        % Middle column (between box and right)
        \def\xmid{5.7}
        \def\xmidtwo{7.2}
        \def\gameedge{4.2}
        
        % === First phase: Key generation ===
        \node at (\xright - 1, 3.8) {$s \gets \text{Gen} \left(1 ^ {n}\right)$};

        \node at (\xright - 1, 3.8) {$s \gets \text{Gen} \left(1 ^ {n}\right)$};
        \draw[block arrow] (\xmidtwo, 3) -- (\gameedge, 3) node [msg, midway] {$s$};

        % === Final output ===
        \def\outputheight{0.8}
        \draw[block arrow] (\gameedge, \outputheight) -- (\xmidtwo, \outputheight) node [msg, midway] {$x, x'$};
    \end{tikzpicture}
    \begin{gather}
        \text{HashColl}_{\Phi, \mathcal{A}} \left(n\right)= \begin{cases}
            1, &\text{ if } H_s \left(x\right) = H_s \left(x'\right) \land x \ne x' \\
            0, &\text{ otherwise}
        \end{cases}
    \end{gather}
\end{center}
% section CRHF (end)

\section{CCA}\label{sec:cca} % (fold)
\begin{definition}[CCA-IND]
    $\Pi$ has indistinguishable encryptions under a chosen-ciphertext attack if for every PPT adversary $\mathcal{A}$
    there exists a negligible function $v \left(\cdot\right)$ such that \[
        \Pr \left[IND_{\Pi, \mathcal{A}}^{CCA} \left(n\right) = 1\right] \leq \displaystyle\frac{1}{2} + v \left(n\right)
    \]
    In this case, we may also say that $\Pi$ is CCA-secure.
\end{definition}

Note that CCA implies authenticity, since given $\text{Enc}_k \left(m\right)$, it is hard to generate $\text{Enc}_k
\left(m'\right)$ for a \enquote{related} $m'$ (such as $m' = m + 1$).

\begin{center}
    \begin{tikzpicture}[
        thick,
        >=stealth,
        every node/.style={align=center},
        msg/.style={text width=3cm, above},
        block arrow/.style={->, very thick},
        loop/.style={out=30, in=-30, distance=1.2cm}
    ]
        % Define vertical spacing
        \def\dy{1.0} % Vertical step between message pairs
        
        % Adversary box
        \draw (0,0) rectangle (4,12) node[pos=0.5] {\huge $\mathcal{A} ^ {\text{Enc}_k \left(\cdot\right), \text{Dec}_k \left(\cdot\right)}$};
        
        % Right column x-position
        \def\xright{9}
        % Middle column (between box and right)
        \def\xmid{5.7}
        \def\xmidtwo{7.2}
        \def\gameedge{4.2}
        
        % === First phase: Key generation ===
        \node at (\xright - 1, 11.8) {$k \gets \text{KeyGen}(1^n)$};

        % Encryption loop
        \begin{scope}[xshift=0.2cm,yshift=10.8cm]
            \coordinate (A-out) at (3.7, 0);
            \coordinate (mid-out) at (\xmid, 0);
            \coordinate (A-in) at (3.7, -\dy);
            \coordinate (mid-in) at (\xmid, -\dy);

            \draw[block arrow] (A-out) -- (mid-out) node [msg, midway] {$m$};
            \draw[block arrow] (mid-in) -- (A-in) node [msg, midway] {$\text{Enc}_k(m)$};
            \draw[block arrow] (mid-out) to [bend left] (mid-in);
            \draw[block arrow] (A-in) to [bend left] (A-out);
        \end{scope}

        % Decryption loop
        \begin{scope}[xshift=0.2cm,yshift=8.3cm]
            \coordinate (A-out) at (3.7, 0);
            \coordinate (mid-out) at (\xmid, 0);
            \coordinate (A-in) at (3.7, -\dy);
            \coordinate (mid-in) at (\xmid, -\dy);

            \draw[block arrow] (A-out) -- (mid-out) node [msg, midway] {$c$};
            \draw[block arrow] (mid-in) -- (A-in) node [msg, midway] {$\text{Dec}_k \left(c\right)$};
            \draw[block arrow] (mid-out) to [bend left] (mid-in);
            \draw[block arrow] (A-in) to [bend left] (A-out);
        \end{scope}

        % === Challenge phase ===
        \begin{scope}[yshift=5.9cm] 
            % Right column node
            \node at (\xright, -0.2 * \dy) {$b \gets \{0, 1\}$};
            \node at (\xright, -0.8 * \dy) {$c^* \gets \text{Enc}_k(m_b)$};

            % Left and middle x positions
            \coordinate (challenge-out) at (\gameedge, 0);
            \coordinate (challenge-mid-out) at (\xmidtwo, 0);
            \coordinate (challenge-in) at (\gameedge, -\dy);
            \coordinate (challenge-mid-in) at (\xmidtwo, -\dy);

            % Arrows
            \draw[block arrow] (challenge-out) -- (challenge-mid-out) 
                node [msg, midway] {$m_0, m_1$};
            \draw[block arrow] (challenge-mid-in) -- (challenge-in) 
                node [msg, midway] {$c^*$};
        \end{scope}

        % Second Ecnryption / Decryption loops
        \begin{scope}[xshift=0.2cm,yshift=4.2cm] % Adjusted to sit below challenge
            \coordinate (A-out) at (3.7, 0);
            \coordinate (mid-out) at (\xmid, 0);
            \coordinate (A-in) at (3.7, -\dy);
            \coordinate (mid-in) at (\xmid, -\dy);

            \draw[block arrow] (A-out) -- (mid-out) node [msg, midway] {$m$};
            \draw[block arrow] (mid-in) -- (A-in) node [msg, midway] {$\text{Enc}_k(m)$};
            \draw[block arrow] (mid-out) to [bend left] (mid-in);
            \draw[block arrow] (A-in) to [bend left] (A-out);
        \end{scope}

        \begin{scope}[xshift=0.2cm,yshift=2.6cm] % Adjusted to sit below challenge
            \coordinate (A-out) at (3.7, 0);
            \coordinate (mid-out) at (\xmid, 0);
            \coordinate (A-in) at (3.7, -\dy);
            \coordinate (mid-in) at (\xmid, -\dy);

            \draw[block arrow] (A-out) -- (mid-out) node [msg, midway] {$c$};
            \draw[block arrow] (mid-in) -- (A-in) node [msg, midway] {$\text{Dec}_k(c)$};
            \draw[block arrow] (mid-out) to [bend left] (mid-in);
            \draw[block arrow] (A-in) to [bend left] (A-out);
        \end{scope}

        % === Final guess ===
        \def\outputheight{0.6}
        \draw[block arrow] (\gameedge, \outputheight) -- (\xmidtwo, \outputheight) node [msg, midway] {$b'$};
    \end{tikzpicture}
    \begin{gather}
        \mathcal{Q} = \text{ set of all decryption queries asked by }\mathcal{A} \\
        \text{IND}_{\Pi, \mathcal{A}} ^ {\text{CCA}} \left(n\right) = \begin{cases}
            1, &\text{ if }b' = b \land c^* \notin \mathcal{Q}\\
            0, &\text{ otherwise}\\
        \end{cases} 
    \end{gather}
\end{center}
% section CCA (end)

\section{Key Agreement}\label{sec:key_agreement} % (fold)
\begin{definition}[Correctness]
    $\Pi$ is a \textbf{key agreement protocol} if there exists a negligible function $v \left(n\right)$ such that for
    all $n \in \N$ \[
        \Pr_{r_A, r_B} \left[K_A \left(1 ^ {n}, r_A, r_B\right) \ne K_B \left(1 ^ {n}, r_A, r_B\right)\right] \leq v
        \left(n\right)
    \]
\end{definition}
This is to say, that $K_i$ generates a different key given the same inputs with an exceedingly low probability. \\ 
The important thing to note here is that Eve is eavesdropping the communication channel, and should not learn
\textbf{any} information on the resulting key. Specifically, from Eve's point of view, the key should be \enquote{as
good as} an independently chosen key.
\begin{definition}[Security]
    A key agreement protocol $\Pi$ is \textbf{secure} if \[
        \left(Transcript_\Pi \left(1 ^ {n}, r_A, r_B\right), K_A \left(1 ^ {n}, r_A, r_B\right)\right) \approx^c
        \left(Transcript_\Pi \left(1 ^ {n}, r_A, r_B\right), K\right)
    \]
    Where $r_A, r_B \gets \left\{0, 1\right\}^ {*},\ K \gets \mathcal{K}_n$ are sampled independently and uniformly.
\end{definition}

In order to create such a protocol, it is important to first remember the definition of \textit{computational
indistinguishability}. Two probability distributions are computationally indistinguishable if no efficient algorithm can
tell them apart: 
\begin{definition}[Computationally indistinguishable]
    Two probability ensembles $X = \left\{X_n\right\}_{n \in \N}, Y = \left\{Y_n\right\}_{n \in \N}$ are
    \textbf{computationally indistinguishable} if for all PPT distinguishers $\mathcal{D}$ there exists a negligible
    function $v \left(\cdot\right)$ such that \[
        \left|\Pr \left[\mathcal{D} \left(1 ^ {n}, x\right)= 1\right] - \Pr \left[\mathcal{D} \left(1 ^ {n}, y\right) -
        1\right]\right| \leq v \left(n\right)
    \]
    Where $x \gets X_n,\ y \gets Y_n$
\end{definition}

\subsection{Diffie-Hellman}\label{sub:diffie_hellman} % (fold)
Let $\mathcal{G}$ be a PPT algorithm that on input $1 ^ {n}$, outputs $\left(\mathbbm{G}, q, g\right)$, where $\mathbbm{G}$ is a cyclic
group of order $q$, that is generated by $g$, and $q$ is an $n$bit prime. Let us assume that $\left(\mathbbm{G}, q, g\right)
\gets \mathcal{G} \left(1 ^ {n}\right)$ is generated, and known to both parties (a publicly published one in the world).

\begin{center}
    \begin{tikzpicture}[
        thick,
        > = Stealth,
        node distance = 2.5cm and 6cm,
        every node/.style = {align=center},
        actor/.style = {text width=4cm, minimum height=4cm, draw, thick, font=\large},
        msg/.style = {->, very thick, above, text width=4cm, align=center},
        label/.style = {font=\footnotesize\sffamily\itshape}
    ]
        % =============== Alice (Left) ===============
        \node[actor] (alice) {
            \textbf{Sample:} $x \gets \mathbb{Z}_q$ \\[1em]
            \textbf{Output:} $h_A = g^x$
        };
        \node at (alice.north west) [anchor=north west, font=\huge, inner sep=8pt] {Alice};

        % =============== Bob (Right) ===============
        \node[actor, right=of alice] (bob) {
            \textbf{Sample:} $y \gets \mathbb{Z}_q$ \\[1em]
            \textbf{Output:} $h_B = g^y$
        };
        \node at (bob.north west) [anchor=north west, font=\huge, inner sep=8pt] {Bob};

        % =============== Vertical offsets for messages ===============
        \def\msgsep{0.5} % Vertical separation between arrows

        % Alice -> Bob: Send X = g^x (top arrow)
        \draw[->, very thick]
            ([yshift=\msgsep cm]alice.east) -- ([yshift=\msgsep cm]bob.west)
            node[midway, above] {$h_A = g^x$};

        % Bob -> Alice: Send Y = g^y (bottom arrow)
        \draw[->, very thick]
            ([yshift=-\msgsep cm]bob.west) -- ([yshift=-\msgsep cm]alice.east)
            node[midway, above] {$h_B = g^y$};

        % =============== Shared secret (below) ===============
        \node[below=0.2cm of alice.south, font=\large] (skA) {Shared key: $K_A = \left(h_B\right)^x = g^{xy}$};
        \node[below=0.2cm of bob.south, font=\large] (skB) {Shared key: $K_B = \left(h_A\right)^y = g^{xy}$};
    \end{tikzpicture}
    \[
    K_A = \left(h_B\right) ^ {x} = \left(g ^ {y}\right) ^ {x} = \left(g ^ {x}\right) ^ {y} = \left(h_A \right) ^ {y} =
    K_B
    \]
\end{center}

So, Alice samples $x \gets \Z_q$, and then computes $h_A = g ^ {x}$, which she sends to Bob. Similarly, Bob samples $y
\gets \Z_q$, computes $h_B = g ^ {y}$, which he sends to Alice. Alice then outputs $K_A = \left(h_B\right) ^ {x}$, and
Bob outputs $K_B = \left(h_A\right) ^ {y}$. 

\begin{definition}[The Decisional Diffie Hellman (DDH) Assumption]
    For every PPT algoirithm $\mathcal{A}$ there exists a negligible function $v \left(\cdot\right)$ such that \[
        \left|\Pr \left[\mathcal{A} \left(\mathbbm{G}, q, g, g ^ {x}, g ^ {y}, g ^ {xz}\right) = 1\right] - \Pr \left[\mathcal{A}
        \left(\mathbbm{G}, q, g, g ^ {x}, g ^ {y}, g ^ {z}\right) = 1\right]\right| \leq v \left(n\right)
    \]
    Where $\left(\mathbbm{G}, q, g\right) \gets \mathcal{G} \left(1 ^ {n}\right)$, and $x, y, z \gets \Z_q$
\end{definition}
Effectively, they made an assumption that it is secure, and it has still not been broken. If you break it, you will get
the Turing prize. Sadly, unlike Computability and Complexity, no guarantees of 100\% in the course. 

\begin{definition}[Computational Diffie-Hellman Assumption]
    For every PPT algorithm $\mathcal{A}$, there exists a negligible function $v \left(\cdot\right)$ such that \[
        \left|\Pr \left[\mathcal{A} \left(\mathbbm{G}, q, g, g ^ {x}, g ^ {y}\right) = g ^ {xy}\right]\right| \leq v \left(n\right)
    \]
    Where $\left(\mathbbm{G}, q, g\right) \gets \mathcal{G} \left(1 ^ {n}\right)$, and $x, y \gets \Z_q$
\end{definition}
If you can solve CDH, then you can also solve DDH, so therefore DDH is a more secure assumption.


% subsection Diffie-Hellman (end)
% section Key Agreement (end)

\pagebreak
\section{Public Key Encryption}\label{sec:public_key_encryption} % (fold)
\begin{definition}[IND-CPA]
    $\Pi$ has indistinguishable encryptions under a chosen-plaintext attack if for every PPT adversary $\mathcal{A}$
    there exists a negligible function $v \left(\cdot\right)$ such that \[
        \Pr \left[IND_{\Pi, \mathcal{A}}^{CPA} \left(n\right) = 1\right] \leq \displaystyle\frac{1}{2} + v \left(n\right)
    \]
\end{definition}

\begin{center}
    \begin{tikzpicture}[thick]
        \draw (0, 0) rectangle (4,5) node[pos=0.5] {\huge $\mathcal{A} $};

        \draw (9, 4.8) node {$\left(sk, pk\right) \gets \text{KeyGen} \left(1 ^ {n}\right)$};
        \draw[->, very thick] (7.2, 4.5) -- (4.2, 4.5) node [above,align=center,midway,text width=3cm] {$pk$};

        \draw[->,very thick] (4.2, 3.8) -- (7.2, 3.8) node [above,align=center,midway,text width=3cm] {$m_0, m_1$};

        \draw (9, 3.3) node {$b \gets \left\{0, 1\right\}$};
        \draw (9, 2.6) node {$c^* \gets \text{Enc}_k \left(m_b\right)$};

        \draw[<-,very thick] (4.2, 2.0) -- (7.2, 2.0) node [above,align=center,midway,text width=3cm] {$c^*$};

        \draw[->,very thick] (4.2, 0.8) -- (7.2, 0.8) node [above,align=center,midway,text width=3cm] {$b'$};
    \end{tikzpicture}
    \[
        \text{IND}_{\Pi, \mathcal{A}} ^ {\text{CPA}} \left(n\right) = \begin{cases}
            1, &\text{ if }b' = b\\
            0, &\text{ otherwise}\\
        \end{cases}
    \]
\end{center}
We will note that this is CPA, despite not having the oracle access, because $\mathcal{A}$ may function as its own
oracle, since access to the public key means that $\mathcal{A}$ may encrypt any message that it wants.
% section Public Key Encryption (end)

\section{Digital Signatures}\label{sec:digital_signatures} % (fold)
\begin{definition}[]
    $\Pi$ is \textbf{existentially unforgeable against an adaptive chosen message attack} if for every PPT adversary
    $\mathcal{A}$, there exists a negligible function $v \left(\cdot\right)$ such that \[
        \Pr \left[\text{SigForge}_{\Pi, \mathcal{A}} \left(n\right) = 1\right] \leq v \left(n\right)
    \]
\end{definition}
Where the SigForge game is: 
\begin{center}
    \begin{tikzpicture}[
        thick,
        >=stealth,
        every node/.style={align=center},
        msg/.style={text width=3cm, above},
        block arrow/.style={->, very thick},
        loop/.style={out=30, in=-30, distance=1.2cm}
    ]
        % Define vertical spacing
        \def\dy{1.0} % Vertical step between message pairs
        
        % Adversary box
        \draw (0,0) rectangle (4,4) node[pos=0.5] {\huge $\mathcal{A} ^ {\text{Sign}_{sk} \left(\cdot\right)}$};
        
        % Right column x-position
        \def\xright{9}
        % Middle column (between box and right)
        \def\xmid{5.7}
        \def\xmidtwo{7.2}
        \def\gameedge{4.2}
        
        % === First phase: Key generation ===
        \node at (\xright - 2, 3.8) {$\left(sk, vk\right) \gets \text{Gen}(1^n)$};
        \def\vkheight{3.0}
        \draw[block arrow] (\xmidtwo, \vkheight) -- (\gameedge, \vkheight) node [msg, midway] {$vk$};

        % Query/Response loop above challenge (first instance)
        \begin{scope}[xshift=0.2cm,yshift=2.2cm]
            \coordinate (A-out) at (3.7, 0);
            \coordinate (mid-out) at (\xmid, 0);
            \coordinate (A-in) at (3.7, -\dy);
            \coordinate (mid-in) at (\xmid, -\dy);

            \draw[block arrow] (A-out) -- (mid-out) node [msg, midway] {$m$};
            \draw[block arrow] (mid-in) -- (A-in) node [msg, midway] {$\text{Sign}_{sk} \left(m\right)$};
            \draw[block arrow] (mid-out) to [bend left] (mid-in);
            \draw[block arrow] (A-in) to [bend left] (A-out);
        \end{scope}

        % === Final output ===
        \def\outputheight{0.3}
        \draw[block arrow] (\gameedge, \outputheight) -- (\xmidtwo, \outputheight) node [msg, midway] {$\left(m^*, t^*\right)$};
    \end{tikzpicture}
    \begin{gather}
        \text{Let }\mathcal{Q} = \text{ the set of all queries asked by } \mathcal{A} \\
        \text{SigForge}_{\Pi, \mathcal{A}} \left(n\right)= \begin{cases}
            1, &\text{ if }\text{Vrfy}_{vk} \left(m^*, \sigma^*\right) = 1 \land m^* \notin \mathcal{Q}\\
            0, &\text{ otherwise}
        \end{cases}
    \end{gather}
\end{center}
% section Digital Signatures (end)

\pagebreak
\section{Cryptography Primitives}\label{sec:cryptography_primitives} % (fold)
\begin{center}
    \begin{tikzpicture}[
        node distance=2cm,
        every node/.style={align=center},
        arrow/.style={->, thick}
    ]

        % --- Left column: assumptions ---
        \node (rsa) {RSA\\Assumption};
        \node (tdp) [below=1.5cm of rsa] {TDP};
        \node (ddh) [below=1.5cm of tdp] {DDH\\Assumption};
        \node (cdh) [below=1.5cm of ddh] {CDH\\Assumption};

        % --- Middle column ---
        \node (fact) [right=2.5cm of rsa] {Factoring\\Assumption};
        \node (dl)   [right=2.5cm of cdh] {DL\\Assumption};
        \node (cpa)  [above=2.5cm of dl] {CPA-Secure\\PKE};

        % --- Right-middle ---
        \node (keyagree) [right=2.5cm of cpa] {Key\\Agreement};
        \node (crhf)     [right=2.5cm of dl] {CRHF};

        % --- Right box of primitives ---
        \node (prims) [right=2.5cm of keyagree, draw, inner sep=8pt] {
            OWF\\[4pt]
            PRG\\[4pt]
            PRF / PRP\\[4pt]
            MAC\\[6pt]
            Signatures\\[6pt]
            Commitments\\[6pt]
            CPA / CCA-Secure\\
            Symmetric-Key\\
            Encryption
        };

        \node (zkp)     [below=1cm of prims] {Zero Knowledge Proofs for NP};

        % --- Arrows ---
        \draw[arrow] (rsa) -- (fact);
        \draw[arrow] (fact) -- (prims);

        \draw[arrow] (rsa) -- (tdp);
        \draw[arrow] (tdp) -- (cpa);

        \draw[arrow] (ddh) -- (cpa);
        \draw[arrow] (ddh) -- (cdh);

        \draw[arrow] (cdh) -- (dl);
        \draw[arrow] (dl) -- (crhf);
        \draw[arrow] (crhf) -- (prims);

        \draw[arrow] (cpa) -- (keyagree);
        \draw[arrow] (keyagree) -- (prims);

        \draw[arrow] (prims) -- (zkp);

    \end{tikzpicture}
\end{center}
% section Cryptography Primitives (end)

\section{Interactive Proofs}\label{sec:interactive_proofs} % (fold)
\begin{definition}[Interactive proof system]
    An \textbf{interactive proof system} for a language $L$ is a protocol $\left\langle \mathcal{P}, \mathcal{V}
    \right\rangle$ where $\mathcal{V}$ is computable in probabilistic polynomial time, and the following holds: \begin{itemize}
        \item Completeness: For every $x \in L$: \[
                \Pr_{r_{\mathcal{P}}, r_{\mathcal{V}}} \left[\text{out}_{\mathcal{V}} \left[\left\langle \mathcal{P},
                \mathcal{V} \right\rangle \left(x\right)\right] = \text{Accept}\right] = 1
            \]
        \item Soundness: For every $x \notin L$, and for every computationally unbounded $\mathcal{P}^*$: \[
                \Pr_{r_{\mathcal{P}}, r_{\mathcal{V}}} \left[\text{out}_{\mathcal{V}} \left[\left\langle \mathcal{P}^*,
                \mathcal{V} \right\rangle \left(x\right)\right] = \text{Accept}\right] \leq \displaystyle\frac{1}{2}
            \]
    \end{itemize}
\end{definition}
We will state that \textbf{IP} is the class of all languages with an interactive proof system. IP contains NP, and in
fact, $IP = PSPACE$. We can reduce the soundness error from $\frac{1}{2}$ to $\varepsilon$ with $\log
\left(\frac{1}{\varepsilon}\right)$ independent repetitions.

Behold, an example of an interactive proof: \\ 
\begin{definition}[Isomorphic]
    Two graphs $G_0 = \left(V_0, E_0\right)$, and $G_1 = \left(V_1, E_1\right)$ are \textbf{isomorphic} if there exists
    a one to one mapping $\pi: V_0 \to V_1$ such that $\left(u, v\right) \in E_0 \Leftrightarrow \left(\pi
    \left(u\right), \pi \left(v\right)\right) \in E_1$ for every $e, v \in V_0$
\end{definition}
We can define the set of isomorphic graphs $GI = \left\{\left(G_0, G_1\right) : G_0 \text{ is isomorphic to }
G_1\right\} \in NP$. Similarly, we can define the other class of graphs that are \textbf{not} isomorphic: $GNI =
\left\{\left(G_0, G_1\right) : G_0 \text{ is \textbf{not} isomorphic to } G_1\right\} \in NP$. This class is not known
to be in NP. \\ 
\begin{center}
    \begin{tikzpicture}[
        thick,
        > = Stealth,
        node distance = 2.5cm and 6cm,
        every node/.style = {align=center},
        actor/.style = {text width=5cm, minimum height=5cm, draw, thick, font=\large},
        msg/.style = {->, very thick, above, text width=4cm, align=center},
        label/.style = {font=\footnotesize\sffamily\itshape}
    ]
        % =============== Prover (Left) ===============
        \node[actor] (prover) {
                Find $z \in \left\{0, 1\right\}$ such that $H$ is isomorphic to $G_z$
        };
        \node at (prover.north west) [anchor=north west, font=\huge, inner sep=8pt] {Prover};

        % =============== Verifier (Right) ===============
        \node[actor, right=of prover] (verifier) {
                Sample a random permutation $\pi$ and $b \gets \left\{0, 1\right\}$. \\[1em]
                Accept \textbf{if and only if} $z = b$
        };
        \node at (verifier.north west) [anchor=north west, font=\huge, inner sep=8pt] {Verifier};

        \node at ($(prover.north)!0.5!(verifier.north) + (0,1.0)$) (input) {
            Common input $\left(G_0, G_1\right)$
        };

        \draw[->, thick] (input) -- (prover);
        \draw[->, thick] (input) -- (verifier);

        % =============== Vertical offsets for messages ===============
        \def\msgsep{0.5} % Vertical separation between arrows

        % Verifier -> Prover: Send isomorphism of one of the input graphs
        \draw[->, very thick]
            ([yshift=\msgsep cm]verifier.west) -- ([yshift=\msgsep cm]prover.east)
            node[midway, above] {$H = \pi \left(G_b\right)$};

        % Prover to Verifier: Return of which graph it is an isomorphism
        \draw[->, very thick]
            ([yshift=-\msgsep cm]prover.east) -- ([yshift=-\msgsep cm]verifier.west)
            node[midway, above] {$z$};
    \end{tikzpicture}

    Proof method
\end{center}
% section Interactive Proofs (end)

\section{Zero Knowledge Proofs}\label{sec:zero_knowledge_proofs} % (fold)
An interactive proof system is zero-knowledge if whatever can be efficiently computed after interacting with
$\mathcal{P}$ on input $x \in L$ can also be computed given only $x$. This should be true even when $\mathcal{P}$ is
interacting with a malicious verifier. 

Again, this is most easily demonstrated with an example. Let us return to Graph Isomorphism, and show that we can prove
the input graphs $G_0, G_1$ are isomorphic without revealing the isomorphism.

\begin{center}
    \begin{tikzpicture}[
        thick,
        > = stealth,
        node distance = 2.5cm and 6cm,
        every node/.style = {align=center},
        actor/.style = {text width=5cm, minimum height=5cm, draw, thick, font=\large},
        msg/.style = {->, very thick, above, text width=4cm, align=center},
        label/.style = {font=\footnotesize\sffamily\itshape}
    ]
        % =============== Prover (Left) ===============
        \node[actor] (prover) {
                Given: $\pi$ such that $\pi \left(G_0\right) = G_1$ \\
                Sample a random permutation $\sigma$ \\
        };
        \node at (prover.north west) [anchor=north west, font=\huge, inner sep=8pt] {Prover};

        % =============== Verifier (Right) ===============
        \node[actor, right=of prover] (verifier) {
                $b \gets \left\{0, 1\right\}$ \\[3em]
                Accept \textbf{if and only if} $\gamma \left(G_b\right) = H$
        };
        \node at (verifier.north west) [anchor=north west, font=\huge, inner sep=8pt] {Verifier};

        \node at ($(prover.north)!0.5!(verifier.north) + (0,1.0)$) (input) {
            Common input $\left(G_0, G_1\right)$
        };

        \draw[->, thick] (input) -- (prover);
        \draw[->, thick] (input) -- (verifier);

        % =============== Vertical offsets for messages ===============
        \def\msgsep{0.5} % Vertical separation between arrows

        % Prover -> Verifier: Send the random permutation of $G_0$
        \draw[->, very thick] 
            ([yshift=2 * \msgsep cm]prover.east) -- ([yshift=2 * \msgsep cm]verifier.west)
            node[midway, above] {$H = \sigma \left(G_0\right)$};

        % Verifier -> Prover: Request demonstration of isomorphism from H to G_b
        \draw[->, very thick]
            (verifier.west) -- (prover.east)
            node[midway, above] {Show me that $H$ is isomorphic to $G_b$};

        % Prover to Verifier: Return isomorphism
        \draw[->, very thick]
            ([yshift=-3 * \msgsep cm]prover.east) -- ([yshift=-3 * \msgsep cm]verifier.west)
            node[midway, above] {$\gamma = \begin{cases}
                \sigma, &\text{ if }b = 0\\
                \sigma \circ \pi ^ {-1}, &\text{ if }b = 1\\
            \end{cases}$};
    \end{tikzpicture}

    Proof method
\end{center}

Consider at the same time that we have the following graphs, allowing us to demonstrate the isomorphism $\pi$ between
$G_0$ and $G_1$, without ever revealing it:
\begin{center}
    \begin{tikzpicture}[node distance=3cm]
        \node[state]              (g0) {$G_0$};
        \node[state, right of=g0] (g1) {$G_1$};
        %\node[state] at ($(g0.north)!0.5!(g1.north) + (0,2.0)$) (h) {$H$};
        \node[state, above of=g0] (h0) {$H$};
        \node[state, above of=g1] (h1) {$H_t$};

        \draw   (g0) edge[->, above, bend left] node{$\pi$} (g1)
                (g1) edge[->, below, bend left] node{$\pi ^ {-1}$} (g0)
                (g0) edge[->, left, bend left] node{$\sigma$} (h0)
                (h0) edge[->, right, bend left] node{$\sigma ^ {-1}$} (g0)
                (g1) edge[->, left, bend left] node{$\sigma$} (h1)
                (h1) edge[->, right, bend left] node{$\sigma ^ {-1}$} (g1)
                (h0) edge[->, above, bend left] node{$\pi$} (h1)
                (h1) edge[->, below, bend left] node{$\pi ^ {-1}$} (h0)
                ;
    \end{tikzpicture} \\
\end{center}
% section Zero Knowledge Proofs (end)


\end{document}
