\documentclass[a4paper]{article}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{blindtext}
\usepackage{multicol}
\usepackage{graphicx}
\usepackage{placeins}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{booktabs}
\usepackage{float}
\usepackage[bookmarks=true]{hyperref}
\usepackage{bookmark}
\usepackage{bbm}
\usepackage{wrapfig}
\usepackage{tabularx}
\usepackage[autostyle=true]{csquotes}
\usepackage{tikz}
\usetikzlibrary{automata, positioning, arrows}
\graphicspath{ {./images/} }
\usepackage[bottom=0.5cm, right=1.5cm, left=1.5cm, top=1.5cm]{geometry}

\newtheorem{theorem}{Theorem}
\newtheorem{exercise}{Exercise}
\newtheorem{example}{Example}
\newtheorem{definition}{Definition}[section]

\newcommand{\R}{\ensuremath{\mathbb{R}}}
\newcommand{\N}{\ensuremath{\mathbb{N}}}
\newcommand{\Z}{\ensuremath{\mathbb{Z}}}
\newcommand{\p}{\ensuremath{\mathbb{P}}}
\newcommand{\E}{\ensuremath{\mathbb{E}}}
\newcommand{\F}{\ensuremath{\mathcal{F}}}
\newcommand{\1}{\ensuremath{\mathbbm{1}}}
\newcommand{\B}{\ensuremath{\mathbbm{B}}}

\title{Lecture 3 - Private key encryption II}
\author{Gidon Rosalki}
\date{2025-11-05}


\begin{document}
\maketitle
\noindent\textbf{Notice:} If you find any mistakes, please open an issue at \href{https://github.com/robomarvin1501/notes\_intro\_to\_crypto}{\texttt{https://github.com/robomarvin1501/notes\_intro\_to\_crypto}}

\section{Recap}%
\label{sec:Recap}
Last week we discussed computational secrecy, which includes indistinguishable encryptions, semantic security. To
achieve this we used the tool of Pseudorandom Generators (PRGs), and investigated One time pads that use PRGs. These
have short keys, but each key can still only be used once. 

\section{Computational Indistinguishability}\label{sec:computational_indistinguishability} % (fold)
Two probability distributions $X = \left\{X_n\right\}_{n \in \N}$ and $Y = \left\{Y_n\right\}_{n \in \N}$ are
computationally indistinguishable if no \enquote{efficient} algorithm \enquote{can tell them apart}. \\ 

\textbf{Example I (PRG G)}: \begin{align*}
    X_n &= G \left(s\right) \text{ for } s \gets \left\{0, 1\right\}^n \\ 
    Y_n &= \text{ uniform distribution over } \left\{0, 1\right\}^{l \left(n\right)}
\end{align*}

\textbf{Example II (IND-secure)}: Let $\Pi = \left(KeyGen, Enc, Dec\right)$: \begin{align*}
    X_n &= Enc_k \left(000\right) \text{ for } k \gets KeyGen \left(1^n\right)
    Y_n &= Enc_k \left(101\right) \text{ for } k \gets KeyGen \left(1^n\right)
\end{align*}

\begin{definition}[Computationally indistinguishable]
    Two probability distributions $X = \left\{X_n\right\}_{n \in \N}$ and $Y = \left\{Y_n\right\}_{n \in \N}$ are
    \textbf{computationally indistinguishable} if for every PPT distinguisher $D$ there exists a negligible function $v
    \left(\cdot\right)$ such that \[
        \left|\Pr_{x \gets X_n} \left[D \left(1^n, x\right) = 1\right] - \Pr_{y \gets Y_n} \left[D \left(1^n, y\right) =
        1\right]\right| \leq v \left(n\right)
    \]
\end{definition}
This is denoted as $X \approx^c Y$.

\begin{theorem}[]
    Let $G: \left\{0, 1\right\}^n \to \left\{0, 1\right\}^{4n}$ be a PRG, then $H \left(s_1, s_2\right) = G
    \left(s_1\right) || G \left(s_2\right)$ is a PRG. 

    \begin{proof}[Proof ]
        Our paradigm for this kind of proof is \textit{reduction} via a \textit{hybrid argument}. \\ 
        \textbf{Reduction}: Given a distinguisher $D$, for $H$, construct a distinguisher $A$ for $G$. \\ 
        \textbf{Hybrid argument}: Let us suppose that between $G \left(s_1\right), G \left(s_2\right)$ $D$ has
        advantage $\varepsilon$. Let us create a new PRG, that given $s_1, s_2$, ignores $s_2$, and returns $G
        \left(s_1\right), r_2$. So, between $G \left(s_1\right), G \left(s_2\right)$ and $G \left(s_1\right), r_2$, it
        holds that $D$ has at least the advantage $\displaystyle\frac{\varepsilon}{2}$, or between $G \left(s_1\right),
        r_2$ and $r_1, r_2$ it holds that $D$ has the advantage of at least $\displaystyle\frac{\varepsilon}{2}$. So:
        \begin{align*}
            \varepsilon &\leq \left|\p \left[D \left(G \left(s_1\right) || G \left(s_2\right)\right) = 1\right] - \p
            \left[D \left(r_1 || r_2\right) = 1\right]\right| \\ 
                        &\leq \left|\p \left[D \left(G \left(s_1\right) || G \left(s_2\right)\right) = 1\right] - \p
                        \left[D \left(G \left(s_1\right) || r_2\right) = 1\right]\right| + \left|\p \left[D \left(G
                        \left(s_1\right) || r_2\right) = 1\right] - \p \left[D \left(r_1 || r_2\right) = 1\right]\right|
        \end{align*}

        Let us define $A$, which on input $z \in \left\{0, 1\right\}^{4n}$ with sample $s_1 \gets \left\{0,
        1\right\}^{n}$ and output $D \left(G \left(s_1\right) || z\right)$. In this case, we have created an adversary
        that distinguishes between the first 2 cases based off the difference of $G \left(s_2\right)$ and $r_2$. We may
        similarly create a second adversary that performs the same, and outputs $D \left(Z || r_2\right)$. Since
        \textit{one} of these transitions must be distinguishable with an advantage of at least
        $\displaystyle\frac{\varepsilon}{2}$, we have found an adversary $A$ for $G$, which is a contradiction to the
        given that $G$ is a PRG.
    \end{proof}
\end{theorem}
% section Computational Indistinguishability (end)

\section{Security against a CPA}\label{sec:security_against_a_cpa} % (fold)
Given $\Pi = \left(KeyGen, Enc, Dec\right)$ and an adversary $\mathcal{A}$, we considered the experiment $IND_{\Pi,
\mathcal{A}} \left(n\right)$. Does this experiment model realistic attacks? Not especially, since it assumes that it can
only observe a single encryption, which is not especially realistic. 

CPA is an extension of this system, where once again, we choose a key $k \gets KeyGen \left(1^n\right)$, $\mathcal{A}$
provides $m_0, m_1$, we choose $b \gets \left\{0, 1\right\}$, return $c^* \gets Enc_k \left(m_b\right)$, and
$\mathcal{A}$ needs to choose $b'$. Here, $\mathcal{A}$ provides as many $m$s for encryption as it likes, which are
encrypted by $k$. Then it provides $m_0, m_1$, $b$ is chosen, and $c^* \gets Enc_k \left(m_b\right)$ is returned to
$\mathcal{A}$. $\mathcal{A}$ can then request more encryptions of $m$s, and then has to return $b'$, which value it
thought $b$ to be. Note, OTP does \textit{not} stand up to this type of attack, nor does any other deterministic
encryption system. \\ 
It may also be said that $\mathcal{A}$ has access to an encryption oracle, denoted $\mathcal{A}^{Enc_k
\left(\cdot\right)}$.

\begin{definition}[CPA secure]
    $\Pi$ has \textbf{indistinguishable encryptions under a chosen plaintext attack} if for every PPT adversary $\mathcal{A}$
    there exists a negligible function $v \left(\cdot\right)$ such that \[
        \Pr \left[IND_{\Pi, \mathcal{A}}^{CPA} \left(n\right) = 1\right] \leq \displaystyle\frac{1}{2} + v \left(n\right)
    \]
\end{definition}
So, a $\Pi$ that is CPA secure must used a \textbf{randomised} encryption algorithm. We will also provide the notation
\[
    IND_{\Pi, \mathcal{A}}^{CPA} \left(n\right) = \begin{cases}
        1, &\text{ if }b' = b\\
        0, &\text{ otherwise}
    \end{cases}
\]

We shall ask, is CPA security \enquote{too strong}? Well, no, since adversaries may often know, influence, or even
determine the encrypted content, and CPA security captures all such influences.
% section Security against a CPA (end)

\section{Pseudorandom functions}\label{sec:pseudorandom_functions} % (fold)
A pseudorandom function is a function that \enquote{looks like} a truly random function. What is a truly random
function? Let there be the sets of all the functions in the world (relevant to us): \begin{gather*}
    Func_{n \to l} = \text{ the set of all functions from } \left\{0, 1\right\}^n \text{ to } \left\{0, 1\right\}^l \\ 
    \left|Func_{n \to l}\right| = \left|\left\{0, 1\right\}^l\right|^{\left|\left\{0, 1\right\}^n\right|} = 2^{l \cdot
    2^n}
\end{gather*}
A truly random function is a function $h$, sampled uniformly from $Func_{n \to l}$. For each $x \in \left\{0,
1\right\}^n$ the value $h \left(x\right) \in \left\{0, 1\right\}^l$ is
chosen uniformly and independently of all other $x$â€™s. \\ 

Pseudorandom functions are an efficiently computable keyed function \[
    F_k \left(\cdot\right): \left\{0, 1\right\}^n \to \left\{0, 1\right\}^l
\]
that is \textit{indistinguishable} from a truly random function. Our distinguisher $\mathcal{D}$ needs to provide an
input $x$, and then distinguish whether or not it received in return $h \left(x\right)$, with $h$ sampled uniformly from
$Func_{n \to l}$, or if it received $F_k \left(x\right)$, where $k$ is sampled uniformly from $\left\{0, 1\right\}^n$.

\begin{definition}[PRF]
    An efficiently computable keyed function \[
        F: \left\{0, 1\right\}^n \times \left\{0, 1\right\}^n \to \left\{0, 1\right\}^{l \left(n\right)}
    \]
    is \textbf{pseudorandom} if for every PPT distinguisher $\mathcal{D}$ there exists a negligible function $v
    \left(\cdot\right)$ such that \[
        \left|\Pr \left[\mathcal{D}^{F_k \left(\cdot\right)} \left(1^n\right) = 1\right] - \Pr \left[\mathcal{D}^{h
        \left(\cdot\right)} \left(1^n\right) = 1\right]\right| \leq v \left(n\right)
    \]
    where $k \gets \left\{0, 1\right\}^n$ and $h \gets Func_{n \to l}$
\end{definition}

This defines the security of PRFs with respect to \textit{uniformly distributed} keys $k \in \left\{0, 1\right\}^n$.
More generally, keys may be of any length, and not uniformly distributed. This is captured via a PPT key-generation
algorithm $k \gets KeyGen \left(1^n\right)$. 

The methodology for using PRFs is as follows: \begin{enumerate}
    \item Prove security assuming a truly random function is used 
    \item Prove that if an adversary can break the scheme when PRF is used, then it can be used to distinguish the PRF
        from a truly random function
\end{enumerate}
% section Pseudorandom functions (end)

\section{CPA secure encryptions from PRFs}\label{sec:cpa_secure_encryptions_from_prfs} % (fold)
Let $F: \left\{0, 1\right\}^n \times \left\{0, 1\right\}^n \to \left\{0, 1\right\}^l$ be a PRF. \begin{itemize}
    \item Key generation: Sample $k \gets \left\{0, 1\right\}^n$
    \item Encryption: On input $k \in \left\{0, 1\right\}^n$ and $m \in \left\{0, 1\right\}^l$, sample $r \gets
        \left\{0, 1\right\}^l$ and we get output \[
            c = \left(r, F_k \left(r\right) \oplus m\right)
        \]
    \item Decryption: On input $k \in \left\{0, 1\right\}^n$ and $c = \left(r, s\right)$, output $m = F_k \left(r\right)
        \oplus s$
\end{itemize}

\begin{theorem}[]
    If $F$ is a PRF, then the scheme $\Pi_F$ above is CPA secure

    \begin{proof}[Proof ]
        We will ebgin by showing that this is a correct encryption scheme: \begin{align*}
            r &\gets \left\{0, 1\right\}^n \\
            Enc \left(k, m\right) &= \left(r, F_k \left(r\right) \oplus m\right) \\
            Dec \left(k, \left(r, s\right)\right) &= F_k \left(r\right) \oplus s \\ 
                                                  &= F_k \left(r\right) \oplus \left(F_k \left(r\right) \oplus
                                                  m\right) \\ 
                                                  &= m
        \end{align*}
        So why does encrypting the same message twice result in a different $c$? Due to $r$ changing every time, and so
        $F_k \left(r\right)$ is a different, completely random seeming series of bits, every time. Consider $m = 0$,
        encrypted many different times. The results will be: \begin{gather*}
            \left(r_1, F_k \left(r_1\right)\right) \\ 
            \left(r_2, F_k \left(r_2\right)\right) \\ 
            \left(r_3, F_k \left(r_3\right)\right) \\ 
            \vdots
        \end{gather*}
        Which are all different, completely random seeming series of bits. 

        So, how will we prove this? Reduction! As always! \\ 
        Consider the above scheme, called $\Pi_F$. Let us define the scheme $\Pi_h$, where instead of using $F_k$, we
        use $h$. We will note that $\Pi_h$ is not efficient, and will not be used in reality, since it uses a truly
        random function. We will show that $\Pi_h$ is CPA, and that we cannot distinguish between $\Pi_h$ and $\Pi_F$,
        and thus $\Pi_F$ is also CPA. 

        Let $\mathcal{A}$ be a PPT adversary, then \begin{align*}
            \Pr \left[IND_{\Pi_F, \mathcal{A}}^{CPA} \left(n\right) = 1\right] &\leq \left|\Pr \left[IND_{\Pi_F,
            \mathcal{A}}^{CPA} \left(n\right) = 1\right] - \Pr \left[IND_{\Pi_h, \mathcal{A}}^{CPA} \left(n\right) =
        1\right]\right| \\ 
                                                                               &+ \p \left[IND_{\Pi_h,
                                                                               \mathcal{A}}^{CPA} \left(n\right) =
                                                                           1\right] \\ 
        \end{align*}
        We will begin by claiming that there exists a negligible $v \left(n\right)$ such that \[
            \left|\Pr \left[IND_{\Pi_F, \mathcal{A}}^{CPA} \left(n\right) = 1\right] - \Pr \left[IND_{\Pi_h,
            \mathcal{A}}^{CPA} \left(n\right) = 1\right]\right| \leq v \left(n\right)
        \]
        We will additionally claim: Let $q \left(n\right)$ be the number of queries made by $\mathcal{A}$ to the
        encryption oracle, then \[
            \Pr \left[IND_{\Pi_h, \mathcal{A}}^{CPA} \left(n\right) = 1\right] \leq \displaystyle\frac{1}{2} +
            \displaystyle\frac{q \left(n\right)}{2^n}
        \]
        So, 
        \begin{align*}
            \Pr \left[IND_{\Pi_F, \mathcal{A}}^{CPA} \left(n\right) = 1\right] &\leq \left|\Pr \left[IND_{\Pi_F,
            \mathcal{A}}^{CPA} \left(n\right) = 1\right] - \Pr \left[IND_{\Pi_h, \mathcal{A}}^{CPA} \left(n\right) =
                1\right]\right| \\ 
                                                                               &+ \p \left[IND_{\Pi_h,
                                                                               \mathcal{A}}^{CPA} \left(n\right) =
                                                                           1\right] \\ 
                                                                               &\leq \displaystyle\frac{1}{2} +
                                                                               \left(\displaystyle\frac{q
                                                                               \left(n\right)}{2^n} + v \left(n\right)\right)
        \end{align*}

        Let us begin with the first claim: There exists negligible $v \left(n\right)$ \[
            \left|\Pr \left[IND_{\Pi_F, \mathcal{A}}^{CPA} \left(n\right) = 1\right] - \Pr \left[IND_{\Pi_h,
            \mathcal{A}}^{CPA} \left(n\right) = 1\right]\right| \leq v \left(n\right)
        \]
        and prove by reduction: Given an adversary $\mathcal{A}$ for the encryption scheme, construct a distinguisher
        $\mathcal{D}$ for the PRF. $\mathcal{D}$ has oracle access to a function $\mathcal{O}$, which is either $F_k
        \left(\cdot\right)$, or a truly random $h \left(\cdot\right)$. $\mathcal{D}$ emulates the CPA experiment to
        $\mathcal{A}$, and observes whether $\mathcal{A}$ succeeds. If $\mathcal{A}$ succeeds, $\mathcal{D}$ outputs 1,
        else, $\mathcal{D}$ outputs 0. \\ 
        Let us assume the contradiction that there exists a PPT adversary $\mathcal{A}$, and a polynomial $p
        \left(n\right)$ such that \[
            \left|\Pr \left[IND_{\Pi_F, \mathcal{A}}^{CPA} \left(n\right) = 1\right] - \Pr \left[IND_{\Pi_h,
            \mathcal{A}}^{CPA} \left(n\right) = 1\right]\right| \geq \displaystyle\frac{1}{p \left(n\right)}
        \]
        for infinitely many $n$s. The distinguisher $\mathcal{D}^{\mathcal{O}}$ will sample $b \gets \left\{0,
        1\right\}$, and invoke $\mathcal{A}$. It will respond to $\mathcal{A}$'s encryption, and challenge queries,
        using $\mathcal{O}$, and output $1$ \textbf{if and only if} $b' = b$. This leaves us with two cases: \begin{enumerate}
            \item $\mathcal{O} = F_k$ where $k \gets \left\{0, 1\right\}^n$. $\mathcal{A}$'s view is identical to
                $IND_{\Pi_F, \mathcal{A}}^{CPA} \left(n\right)$ \[
                    \Pr \left[D^{F_k \left(\cdot\right)} \left(1^n\right) = 1\right] = \Pr \left[IND_{\Pi_F,
                    \mathcal{A}}^{CPA} \left(n\right) = 1\right]
                \]
            \item $\mathcal{O} = h$, where $h \gets Func_{n \to l}$. Here, $\mathcal{A}$'s view is identical to
                $IND_{\Pi_h, \mathcal{A}}^{CPA} \left(n\right)$ and \[
                    \Pr \left[D^{h \left(\cdot\right)} \left(1^n\right) = 1\right] = \Pr \left[IND_{\Pi_h,
                    \mathcal{A}}^{CPA} \left(n\right) = 1\right]
                \]
        \end{enumerate}
        Thus a contradiction, and we have shown claim 1. 

        Claim 2: Let $q \left(n\right)$ be the number of queries made by $\mathcal{A}$ to the encryption oracle, then \[
            \Pr \left[IND_{\Pi_h, \mathcal{A}}^{CPA} \left(n\right) = 1\right] \leq \displaystyle\frac{1}{2} +
            \displaystyle\frac{q \left(n\right)}{2^n}
        \]
        Each encryption query $m_i$ is answered with $\left(r_i, h \left(r_i\right) \oplus m_i\right)$ for a uniform,
        and independently chosen $r_i \gets \left\{0, 1\right\}^n$. The \textit{repeat} is the event in which $r^*$ is
        used at least once by the encryption oracle (ie $r^* = r_i$). If \textit{repeat} does not occur, then $h
        \left(r^*\right)$ is completely uniform and independent of $\mathcal{A}$'s view, and therefore $\mathcal{A}$'s
        view is independent of $b$: \[
            \Pr \left[IND_{\Pi_h, \mathcal{A}}^{CPA} \left(n\right) = 1 | \overline{\text{\textit{Repeat}}}\right] =
            \displaystyle\frac{1}{2}
        \]
        So \begin{align*}
            \Pr \left[IND_{\Pi_h, \mathcal{A}}^{CPA} \left(n\right) = 1 \right] &\leq \Pr \left[IND_{\Pi_h,
            \mathcal{A}}^{CPA} \left(n\right) = 1 | \overline{\text{\textit{Repeat}}}\right] + \Pr
            \left[\text{\textit{Repeat}}\right] \\ 
                                                                                &= \displaystyle\frac{1}{2} +
                                                                                \displaystyle\frac{q \left(n\right)}{2^n}
        \end{align*}
    \end{proof}
\end{theorem}

Our world of crypto primitives so far is from PRF, we can build both PRG, and CPA-secure symmetric key encryption, and
from both PRG, and CPA-secure symmetric key encryption, we can build IND-secure symmetric key encryption.
\begin{center}
\begin{tikzpicture}[
    node distance=3cm and 4cm,
    state/.style={draw, rounded corners, minimum width=3cm, minimum height=1cm, align=center},
    every edge/.style={draw, ->, thick}
]
    % Nodes
    \node[state] (prf) {PRF};
    \node[state, right=of prf] (prg) {PRG};
    \node[state, below=of prf] (cpa) {CPA-secure \\ symmetric encryption};
    \node[state, below=of prg] (ind) {IND-secure \\ symmetric encryption};

    % Arrows
    \draw (prf) edge[above] node[font=\small]{via construction} (prg);
    \draw (prg) edge[right] node[font=\small]{implies} (ind);
    \draw (prf) edge[left] node[font=\small]{used to build} (cpa);
    \draw (cpa) edge[below] node[font=\small]{implies} (ind);
\end{tikzpicture}
\end{center}

% section CPA secure encryptions from PRFs (end)

\section{Practical heuristics block ciphers}\label{sec:practical_heuristics_block_ciphers} % (fold)
In practice, block ciphers are designed to be secure instantiations of pseudorandom permutations (PRPs).  A block cipher
is an efficiently-computable keyed permutation \[
    F: \left\{0, 1\right\}^n \times \left\{0, 1\right\}^l \to \left\{0, 1\right\}^l
\]
They have concrete security rather than asymptotic security, and a block cipher is considered \enquote{secure} if the best known
\enquote{attack} requires time roughly $2^n$ ($\approx$brute-force search for the key). 

DES was the The Data Encryption Standard. It was developed in the 1970s by IBM, with help from the NSA, and adopted in
1977. The key length is 56 bits, with block length of 64 bits. The best known attack in practice is essentially a brute
force key search, which is eminently possible by your smartphone, since the key length is so short. Thus it is no longer
considered secure. It remains widely used in the strengthened form 3DES: \[
    3DES_{k_1, k_2, k_3} \left(x\right) = DES_{k_1} \left(DES_{k_2}^{-1} \left(DES_{k_3} \left(x\right)\right)\right)
\]
So there are $3 \cdot 56$ bit keys, but can be broken in $2^{2 \cdot 56}$. It is also (unsurprisingly) slower than DES. 

These days, we have moved on from DES to AES. In 1997 NIST published a call fro candidate block ciphers to replace DES.
15 candidates were proposed, each being extensibely analysed by the public and other teams. The winner (originall called
Rijndael) was announced in late 2000, and was chosen based on security, efficiency, ability to implement in hardware,
and so on. It uses key lengths of 128/192/256, with a block length of 128 bits. To date, there are no known practical
attacks better than brute-force key search. It is massively widely used, with all modern hardware having built in
optimisations. Recall the definition of CPA secure encryption from any PRF: \[
    Enc_k \left(m; r\right) = \left(r, F_k \left(r\right) \oplus m\right)
\]
In practice, AES as a PRF enables one to encrypt 128 bit blocks: \[
    Enc_k \left(m; r\right) = \left(r, AES_k \left(r\right) \oplus m\right)
\]
Why not simply $AES_k \left(m\right)$? AES is deterministic, and so susceptible to CPA attacks.

In order to encrypt long messages, we break them up into 128 bit blocks: \[
    Enc_k \left(m_1 \dots m_l; r_1 \dots r_l\right) = \left(r_1, AES_k \left(r_1\right) \oplus m_1\right) \dots \left(r_l, AES_k \left(r_l\right) \oplus m_l\right)
\]
This has the drawback of the ciphertext length being twice the plaintext. This can be improved by changing the structure
slightly: \[
    Enc_k \left(m_1 \dots m_l; r_1\right) = \left(r, AES_k \left(r + 1\right) \oplus m_1\right) \left(AES_k \left(r +
    2\right) \oplus m_l\right) \dots \left(AES_k \left(r + l\right) \oplus m_l\right)
\]
This is called \textit{counter mode}
\begin{theorem}[]
    If $F$ is a PRF, then counter mode is CPA secure. 

    \begin{proof}[Proof overview]
        Assume for simplicity that all messages consist of $l$ blocks. The sequence \[
            s_i = \left(r_i, F_k \left(r_i + 1\right), \dots, F_k \left(r_i + l\right)\right)
        \]
        used for encrypting the $i$th message is pseudorandom. Any $s_i$, and $s_{i'}$ are \enquote{independent} , unless
        $r_i + j = r_{i'} + j'$
    \end{proof}
\end{theorem}

There is also ECB mode (electronic code book), where \[
    Enc_k \left(m_1 \dots m_l\right)= \left(F_k \left(m_1\right), F_k \left(m_2\right), \dots, F_k \left(m_l\right)\right)
\]
ECB mode is deterministic and thus \textbf{not secure}. 
\begin{figure}[H]
    \center
    \includegraphics[scale=0.2]{lecture_3_ecb_mode}
    \caption{ECB mode}
\end{figure}

We can map from PRGs to PRFs 

\begin{theorem}[]
    Let $G$ be a PRG with expansion $2n$, then there exists a PRF $F$ mapping $n$-bit inputs to
    $n$-bit outputs
\end{theorem}

We will construct as follows: We will denote $G \left(s\right) = G_0 \left(s\right) G_1 \left(s\right)$, where
\begin{gather*}
    \left|G_0 \left(s\right)\right| = \left|G_1 \left(s\right)\right| = \left|s\right|
\end{gather*}
We will define \begin{gather*}
    F_k \left(x\right)= G_{x_n} \left(\dots G_{x_1} \left(k\right) \dots\right) \\ 
    \text{where } x = x_1 \dots x_n
\end{gather*}
We can then construct a binomial tree, starting at $k$, who has the children $G_0 \left(k\right)$ and $G_1
\left(k\right)$, and keep this iteration going. The series of subfixes to $G$ will indicate the value given to $F_k$,
for example the node $G_1 \left(G_1 \left(k\right)\right)$ will represent $F_k \left(11\right)$.
\begin{figure}[H]
    \center
    \includegraphics[scale=0.2]{lecture_3_prf_tree}
    \caption{PRG to PRF tree}
\end{figure}

This can be proven using the hybrid $\mathcal{H}_i$. Values on level $i$ are sampled uniformly, and independently.
Values on all levels $\geq i$ are computed using $G$. This has the problem that level $i$ has $2^i$ values, but we can
resolve this given $\mathcal{D}$ runs in time $t = t \left(n\right)$, we need at most $t$ values for the $i$th level. We
reduce to distinguishing $G \left(s_1\right) \dots G \left(s_t\right)$ from $U_{2tn}$

% section Practical heuristics block ciphers (end)
\end{document}
