\documentclass[a4paper]{article}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{blindtext}
\usepackage{multicol}
\usepackage{graphicx}
\usepackage{placeins}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{booktabs}
\usepackage{float}
\usepackage[bookmarks=true]{hyperref}
\usepackage{bookmark}
\usepackage{bbm}
\usepackage{wrapfig}
\usepackage{tabularx}
\usepackage{tikz}
\usetikzlibrary{automata, positioning, arrows, arrows.meta, calc}
\usepackage[autostyle=true]{csquotes}
\graphicspath{ {./images/} }
\usepackage[bottom=0.5cm, right=1.5cm, left=1.5cm, top=1.5cm]{geometry}

\newtheorem{theorem}{Theorem}
\newtheorem{exercise}{Exercise}
\newtheorem{example}{Example}
\newtheorem{definition}{Definition}[section]

\newcommand{\R}{\ensuremath{\mathbb{R}}}
\newcommand{\N}{\ensuremath{\mathbb{N}}}
\newcommand{\Z}{\ensuremath{\mathbb{Z}}}
\newcommand{\p}{\ensuremath{\mathbb{P}}}
\newcommand{\E}{\ensuremath{\mathbb{E}}}
\newcommand{\F}{\ensuremath{\mathcal{F}}}
\newcommand{\1}{\ensuremath{\mathbbm{1}}}
\newcommand{\B}{\ensuremath{\mathbbm{B}}}

\title{Lecture 4}
\author{Gidon Rosalki}
\date{2025-11-19}


\begin{document}
\maketitle
\noindent\textbf{Notice:} If you find any mistakes, please open an issue at \href{https://github.com/robomarvin1501/notes\_intro\_to\_crypto}{\texttt{https://github.com/robomarvin1501/notes\_intro\_to\_crypto}}

\section{Introduction}\label{sec:introduction} % (fold)

We are going to discuss Message Authentication Codes, where we verify the authenticity of a sent message. You receive a
message, and can verify that it came from \textit{me}, and nobody else (Like Eve. Seriously, screw Eve. Or don't, that
might be what she wants).

We are going to discuss authenticating fixed length messages, and arbitrary length messages. We will do this through
collision resistant hash functions, where we use the \enquote{hash and authenticate} paradigm. After this, we will link
it back to encryption.

% section Introduction (end)

\section{Message authentication}\label{sec:message_authentication} % (fold)
Alice and Bob wish to communicate, and Eve completely controls the channel. We would like to assure the receiver of a
message, that it has not been modified. If Alice sends Bob a message that says \enquote{Pay Charlie \$10}, Eve can
change it to say \enquote{Pay Eve \$10,000} (You may also pretend that Bob is your Bank). Encryption ensures data
secrecy, that no one else knows the contents, and \textit{authentication} ensures the integrity of the data, that it
remained unchanged. These concepts are orthogonal, one does not enable the other.

\subsection{Message Authentication Code (MAC)}\label{sub:message_authentication_code_mac_} % (fold)
The syntax is $\Pi = \left(Gen, Mac, \text{Vrfy}\right)$, where the key-generation algorithm $Gen$ on input $1^n$ outputs a key
$k$, the tag generation algorithm $Mac$ takes a key $k$, and a message $m \in \left\{0, 1\right\}^*$, and outputs a tag
$t \in \left\{0, 1\right\}^*$, and the verification algorithm Vrfy takes a key $k$, message $m$, and tag $t$, and
outputs a bit $b$. \\ 
The correctness comes from: \[
    \forall k, m\ \text{Vrfy}_k \left(m, Mac_k \left(m\right)\right) = 1
\]
The security of MACs is found as follows: The adversary $\mathcal{A}$ can adaptively ask for tags of messages of its choice, and
attempts to forge a valid tag on a new message $\left(m^*, t^*\right)$. Let $Q$ be the set of all queries asked by $\mathcal{A}$.
We then have \[
    MacForge_{\Pi, \mathcal{A}} \left(n\right) = \begin{cases}
        1, &\text{ if }\text{Vrfy}_k \left(m^*, t^*\right) = 1 \land m^* \notin Q\\
        0, &\text{ otherwise}
    \end{cases}
\]

\begin{definition}[MAC scheme]
    A MAC scheme $\Pi = \left(Gen, Mac, \text{Vrfy}\right)$ is secure if for every PPT adversary $\mathcal{A}$, there
    exists a negligible function $v \left(\cdot\right)$ such that \[
        \Pr \left[MacForge_{\Pi, \mathcal{A}} \left(n\right) = 1\right] \leq v \left(n\right)
    \]
\end{definition}
This definition does \textbf{not} prevent replay attacks. Eve may send the message \enquote{Send Charlie \$10} as many
times as she likes, and it will appear legitimate, thanks to the deterministic MAC.
% subsection Message Authentication Code (MAC) (end)

\subsection{Fixed length MAC}\label{sub:fixed_length_mac} % (fold)
Let $F: \left\{0, 1\right\}^n \times \left\{0, 1\right\}^n \to \left\{0, 1\right\}^n$ be a PRF. \begin{itemize}
    \item Key generation: Sample $k \gets \left\{0, 1\right\}^n$ 
    \item Tag generation: On input $k \in \left\{0, 1\right\}^n$ and $m \in \left\{0, 1\right\}^n$ output $t = F_k
        \left(m\right)$ 
    \item Verification: On input $k \in \left\{0, 1\right\}^n$, $m \in \left\{0, 1\right\}^n$, and $t \in \left\{0,
        1\right\}^n$, output $1$ if $t = F_k \left(m\right)$, and 0 otherwise
\end{itemize}

\begin{theorem}[]
    If $F$ is a PRF, then the above MAC scheme is secure
    \begin{proof}[Proof ]
        The concept is that given a forger $\mathcal{A}$, for the MAC scheme, we construct a distinguisher
        $\mathcal{D}$ for the PRF. $\mathcal{D}$ has oracle access to a function $\mathcal{O}$, which is either $F_k$,
        or a truly random $h$. Additionally, $\mathcal{D}$ runs $\mathcal{A}$ internally, and simulates the experiment
        $MacForge_{\Pi, \mathcal{A}}$ to $\mathcal{A}$ using $\mathcal{O}$.
        
        Let us assume towards a contradiction that there exists a PPT adversary $\mathcal{A}$, and a polynomial $p
        \left(n\right)$ such that \[
            \Pr \left[MacForge_{\Pi, \mathcal{A}} \left(n\right) = 1\right] \geq \displaystyle\frac{1}{p \left(n\right)}
        \]
        for infinitely many $n$s. The distinguisher $\mathcal{D}^\mathcal{O}$ will invoke $\mathcal{A}$, and respond to
        each of its queries $m$ with $t = \mathcal{O} \left(m\right)$. It will output 1 \textbf{if and only if} $m^*
        \notin \mathcal{Q}$, and $t^* = \mathcal{O} \left(m^*\right)$, where $\mathcal{Q}$ is the set of all queries
        asked by $\mathcal{A}$. There are 2 cases: \\ 
        \textbf{Case 1}: If $\mathcal{O} = F_k$ is a PRF, then $\mathcal{A}$'s view is identical to $MacForge_{\Pi,
        \mathcal{A}} \left(n\right)$, and so \[
            \Pr \left[D^{F_k \left(\cdot\right)} \left(1 ^ {n}\right) = 1\right] = \Pr \left[MacForge_{\Pi, \mathcal{A}}
            \left(n\right) = 1\right]
        \]
        \textbf{Case 2}: If $\mathcal{O} = h$ is a truly random function, then if $m^* \notin \mathcal{Q}$, then
        $\mathcal{A}$'s view is independent of $\mathcal{O} \left(m^*\right)$, and so \[
            \Pr \left[D^{h \left(\cdot\right)} \left(1^n\right) = 1\right] = 2 ^ {-n}
        \]

        From here, we may calculate \begin{gather}
            \left|\Pr \left[D^{F_k \left(\cdot\right)} \left(1^n\right) = 1\right] - \Pr \left[D^{h \left(\cdot\right)}
            \left(1^n\right) = 1\right]\right| \\ 
            = \left|\Pr \left[MacForge_{\Pi, \mathcal{A}} \left(n\right) = 1\right] - 2^{-n}\right| \\ 
            \geq \displaystyle\frac{1}{p \left(n\right)} - 2^{-n} \\
        \end{gather}
        So, we have successfully distinguished between a truly random function, and a PRF, which is a contradiction.
    \end{proof}
\end{theorem}
% subsection Fixed length MAC (end)

\subsection{Arbitrary length messages}\label{sub:arbitrary_length_messages} % (fold)
Given \[
    \widehat{\Pi} = \left(\widehat{\text{Gen}}, \widehat{\text{Mac}}, \widehat{\text{Vrfy}}\right)
\]
for fixed length messages, we want to define $\Pi = \left(Gen, Mac, \text{Vrfy}\right)$ for arbitrary length
messages. Here is a first (naÃ¯ve) attempt: 
\subsubsection{Attempt 1}\label{sec:attempt_} % (fold)
Let $Mac_k \left(m\right) = \left(t_1, \dots, t_d\right)$ where $t_i = \widehat{\text{Mac}}_k \left(m_i\right)$, $Gen =
\widehat{\text{Gen}}$, and $\text{Vrfy}_k \left(\left(m_1, \dots, m_d\right), \left(t_1, \dots, t_d\right)\right) = 1$
\textbf{if and only if} $\widehat{\text{Vrfy}}_k \left(m_i, t_i\right) = 1$ for every $i \in \left[d\right]$. 

This is completely insecure. Consider \[
    t = \left(t_1, t_2\right)
\]
If $t$ is a valid tag for $m = \left(m_1, m_2\right)$, then it also holds that $t^* = t_1$ is a valid tag for $m^* =
m_1$. 
% subsubsection Attempt 1 (end)

\subsubsection{Attempt 2}\label{sec:attempt_} % (fold)
$Mac_k \left(m\right) = \left(t_1, \dots, t_d\right)$, where $t_i = \widehat{\text{Mac}}_k \left(d, m_i\right)$, $\text{Gen}
= \widehat{\text{Gen}}$, and $\text{Vrfy}_k \left(\left(m_1, \dots, m_d\right), \left(t_1, \dots, t_d\right)\right) = 1$
\textbf{if and only if} $\widehat{\text{Vrfy}}_k \left(\left(d, m_i\right), t_i\right) = 1$  for every $i \in
\left[d\right]$.

This is also insecure. Consider if $t = \left(t_1, t_2\right)$ is a valid tag for $m = \left(m_1, m_2\right)$, then $t^*
= \left(t_2, t_1\right)$ is a valid tag for $m^* = \left(m_2, m_1\right)$. 
% subsubsection Attempt 2 (end)

\subsubsection{Attempt 3}\label{sec:attempt_} % (fold)
$Mac_k \left(m\right) = \left(t_1, \dots, t_d\right)$, where $t_i = \widehat{\text{Mac}}_k \left(d, i, m_i\right)$, $\text{Gen}
= \widehat{\text{Gen}}$, and $\text{Vrfy}_k \left(\left(m_1, \dots, m_d\right), \left(t_1, \dots, t_d\right)\right) = 1$
\textbf{if and only if} $\widehat{\text{Vrfy}}_k \left(\left(d, i, m_i\right), t_i\right) = 1$  for every $i \in
\left[d\right]$.

This is still insecure. If $t = \left(t_1, t_2\right)$ is a valid tag for $m = \left(m_1, m_2\right)$, and similarly $t'
= \left(t_1', t_2'\right)$ is a valid tag for $m' = \left(m_1', m_2'\right)$, then $t^* = \left(t_1, t_2'\right)$ is a
valid tag for $m^* = \left(m_1, m_2'\right)$
% subsubsection Attempt 3 (end)

\subsubsection{Solution 1}\label{sec:solution_} % (fold)
$Mac_k \left(m\right) = \left(r, t_1, \dots, t_d\right)$, where $t_i = \widehat{\text{Mac}}_k \left(r, d, i, m_i\right)$,
and $r$ is sampled uniformly, and independently for each message $m$. $\text{Gen} = \widehat{\text{Gen}}$, and
$\text{Vrfy}_k \left(\left(m_1, \dots, m_d\right), \left(r, t_1, \dots, t_d\right)\right) = 1$ \textbf{if and only if}
$\widehat{\text{Vrfy}}_k \left(\left(r, d, i, m_i\right), t_i\right) = 1$  for every $i \in \left[d\right]$.

This is a solution, but has the drawback of very long tags.
% subsubsection Solution 1 (end)

\subsubsection{Solution 2 (CBC-MAC)}\label{sec:solution_cbc_mac_} % (fold)
Let $Mac_k \left(m\right)= t_d$, where \begin{itemize}
    \item $t_0 = 0^n$, and $t_i = F_k \left(t_{i - 1} \oplus m_i\right)$ for $i \in \left[d\right]$
    \item $F_k$ can be any PRF
    \item $d$ must be fixed ahead of time
\end{itemize}
In short, we take the result of the signature of the first block $m_1$, and XOR it with the second block $m_2$, and then
compute the signature of that. This is continued on recursively until the end: 

\begin{figure}[H]
    \center
    \includegraphics[scale=0.2]{lecture_4_CBCMAC}
    \caption{CBC-MAC}
\end{figure}

This is great because it is very easy to implement, so that solves many bug issues, and lots of the parts may be
implemented in hardware. 
% subsubsection Solution 2 (CBC-MAC) (end)

\subsubsection{Solution 3 - Hash and Authenticate}\label{sec:solution_hash_and_authenticate} % (fold)
We will compress $m$ into a short fingerprint $H \left(m\right)$, and then authenticate $H \left(m\right)$ instead of
$m$ itself. It is critical for our hashing function $H$, that it is very difficult to find $m \ne m'$ such that $H
\left(m\right) = H \left(m'\right)$.
% subsubsection Solution 3 - Hash and Authenticate (end)
% subsection Arbitrary length messages (end)
% section Message authentication (end)

\section{Collision-Resistant Hash Functions}\label{sec:collision_resistant_hash_functions} % (fold)
The purpose of Collision-Resistant Hash Functions is that they compress arbitrarily long inputs into short,
fixed-length outputs. It should be very hard to find $x \ne x'$ such that $H \left(x\right) = H \left(x'\right)$.

Syntactically: $\Phi = \left(\text{Gen}, H\right)$: 
\begin{itemize}
    \item The key generation algorithm Gen, on input $1^n$ outputs a key $s$
    \item The evaluation algorithm $H$ on input $s$, and $x \in \left\{0, 1\right\}^*$ outputs $H_s \left(x\right) \in
        \left\{0, 1\right\} ^ {l \left(n\right)}$
\end{itemize}
So, our adversary is playing \[
    HashColl_{\Phi, \mathcal{A}} \left(n\right) = \begin{cases}
        1, &\text{ if }H_s \left(x\right) = H_s \left(x'\right) \land x \ne x'\\
        0, &\text{ otherwise }\\
    \end{cases}
\]
Bringing us to the definition 
\begin{definition}[Collision Resistant]
    $\Phi$ is \textbf{collision resistant} if for every PPT adversary $\mathcal{A}$ there exists a negligible function
    $v \left(\cdot\right)$ such that \[
        \Pr \left[HashColl_{\Phi, \mathcal{A}} \left(n\right) = 1\right] \leq v \left(n\right)
    \]
\end{definition}

Can we find collisions? Well, if our function produces output of length $n$ bits, then we could $2^n + 1$ inputs, but
this will take forever. Instead, we have \textbf{The Birthday Attack}. \\ 
Given $H : \left\{0, 1\right\}^* \to \left\{0, 1\right\}^l$, sample $q = \mathcal{O} \left(2^{\frac{l}{2}}\right)$
inputs uniformly and independently. This finds colliding pair of inputs with a constant probability ($2^l$ pairs). To
think about this in general, given output of $2^n$, then similar to the birthday paradox from probability and
statistics, taking $\sqrt{2^n} = 2^{\frac{n}{2}}$ possible inputs, and testing them, will give us a shared output with
probability of 50\%. 

In practice $l \geq 128$. Popular heuristic (unkeyed) functions include MD5, SHA1, SHA3, and so on. Both MD5, and SHA1
are horrifically insecure, but still heavily used. They can still be useful in non crypto contexts, but should now
\textit{never} be used in a crypto context. 

Generally, in order to to create an arbitrary length hash function, we start with a fixed length has function, and
extend it. 
% section Collision-Resistant Hash Functions (end)

\section{Authenticating Arbitrary-Length Messages}\label{sec:authenticating_arbitrary_length_messages} % (fold)
Given \[
    \widehat{\Pi} = \left(\widehat{\text{Gen}}, \widehat{\text{Mac}}, \widehat{\text{Vrfy}}\right)
\]
for fixed length messages, and a collision resistant hash function $\Phi = \left(Gen_H, H\right)$, define $\Pi =
\left(Gen, Mac, \text{Vrfy}\right)$ for arbitrary length messages. 

Reconsider Solution 3 above: \\
\begin{itemize}
    \item $Mac_{k, s} \left(m\right) = \widehat{Mac}_k \left(H_s \left(m\right)\right)$
    \item $Gen = \left(\widehat{Gen}, Gen_H\right)$
    \item $\text{Vrfy}_{k, s} \left(m, t\right) = 1 \Leftrightarrow \widehat{Vrfy}_k \left(H_s \left(m\right), t\right) = 1$
\end{itemize}

\begin{exercise}
    Let $Mac_k \left(m\right)$ sample $s \gets Gen_H \left(1^n\right)$, and outputs $\left(s, \widehat{Mac}_k \left(H_s
    \left(m\right)\right)\right)$. Is this secure? 

    \begin{proof}[Solution]
        This is insecure. In general, our family our functions should overall be difficult to find collisions within,
        but it is \textit{possible} that there exists a function within the family where it is incredibly easy to find
        within it collisions. Since $s$ is generated, our adversary can choose an $s$ for which the function $H_s$ has
        many collisions. Consider the following: \begin{itemize}
            \item The adversary requests the signature of 0, and gets in response $\left(s, Mac_k \left(H_s
                \left(0\right)\right)\right)$. Let us denote $a = H_s \left(0\right)$. 
            \item We will now find a function within the family that maps \textit{everything} to $a$. 
            \item The adversary will now pick this value for $s$, and the signature of every message $m$ will be \[
                    Mac_k \left(H_s \left(m\right)\right) = Mac_k \left(a\right) = Mac_k \left(H_s \left(0\right)\right)
            \]
    \end{itemize}
    \end{proof}
\end{exercise}
 Let us return to Solution 3. \begin{theorem}[]
    If $\widehat{\Pi}$ is a secure MAC, and $\Phi$ is collision resistant, then $\Pi$ is a secure MAC.

    \begin{proof}[Proof ]
        Consider the event \enquote{collision}. $\mathcal{A}$ asks for a tag on some $m_i$ such that $m_i \ne m^*$, and $H_s
        \left(m_i\right) = H)s \left(m^*\right)$. Whenever \enquote{collision} occurs, then we can use $\mathcal{A}$ to
        find a non trivial collision, and whenever \enquote{collision} does not occur (and $\mathcal{A}$ wins), then we
        can use $\mathcal{A}$ to forge a tag on the fixed length message \[
            H_s \left(m^*\right) \notin \left\{H_s \left(m_1\right), \dots, H_s \left(m_q\right)\right\}
        \]

        Let $\mathcal{A}$ be any PPT adversary, then \begin{align*}
            \Pr \left[MacForge_{\Pi, \mathcal{A}} \left(n\right) = 1\right] &\leq \Pr \left[\text{collision}\right] +
            \Pr \left[MacForge_{\Pi, \mathcal{A}} \left(n\right) \land \overline{\text{collision}}\right] \\ 
        \end{align*}
        Since \[
            \Pr \left[A\right] = \Pr \left[A \land B\right] + \Pr \left[A \land \overline{B}\right] \leq \Pr
            \left[B\right] + \Pr \left[A \land \overline{B}\right]
        \]

        Let \textbf{claim I} be that there exists a negligible function $v_1 \left(n\right)$ such that \[
            \Pr \left[\text{collision}\right] \leq v_1 \left(n\right)
        \]
        and \textbf{claim II} be that there exists a negligible function $v_2 \left(n\right)$ such that \[
            \Pr \left[MacForge_{\Pi, \mathcal{A}} \left(n\right) \land \overline{\text{collision}}\right] \leq v_2
            \left(n\right) 
        \]

        Proof of Claim I: \\
        Let us assume towards a contradiction that there exists a PPT adversary $\mathcal{A}$, and a polynomial $p
        \left(n\right)$ such that \[
            \Pr \left[\text{collision}\right] \geq \displaystyle\frac{1}{p \left(n\right)}
        \]
\begin{center}
    \begin{tikzpicture}[
        thick,
        >=stealth,
        every node/.style={align=center},
        msg/.style={text width=3cm, above},
        block arrow/.style={->, very thick},
        loop/.style={out=30, in=-30, distance=1.2cm}
    ]
        % Define vertical spacing
        \def\dy{1.0} % Vertical step between message pairs

        % Distinguisher box
        \draw (0, 0) rectangle (8, 6);
        \node at (-0.5, 6.5) [anchor=north west, inner sep=1cm] {\huge $\mathcal{C}$};
        \node at (-0.9, 6) [anchor=north west, inner sep=1cm] {$k \gets \widehat{Gen} \left(1 ^ {n}\right)$};

        \draw[block arrow] (12.2, 5.5) -- (8.2, 5.5) node [msg, midway] {$s$};

        
        % Adversary box
        \draw (2.3, 1) rectangle (4.3, 5) node[pos=0.5] {\huge $\mathcal{A} \left(1 ^ {n}\right)$};
        
        \begin{scope}[xshift=0.3cm,yshift=2cm]
            % Right column x-position
            \def\xright{4}
            % Middle column (between box and right)
            \def\xmid{6.7}
            \def\xmidtwo{7.2}
            \def\gameedge{4.2}

            % === Second query/response phase (after challenge) ===
            \begin{scope}[xshift=0.2cm,yshift=2.8cm] % Adjusted to sit below challenge
                \coordinate (A-out) at (3.7, 0);
                \coordinate (mid-out) at (\xmid, 0);
                \coordinate (A-in) at (3.7, -\dy);
                \coordinate (mid-in) at (\xmid, -\dy);

                \draw[block arrow] (A-out) -- (mid-out) node [msg, midway] {$m_i$};
                \draw[block arrow] (mid-in) -- (A-in) node [msg, midway] {$\widehat{MAC}_k \left(H_s \left(m_i\right)\right)$};
                \draw[block arrow] (mid-out) to [bend left] (mid-in);
                \draw[block arrow] (A-in) to [bend left] (A-out);
            \end{scope}

            % === Final guess ===
            \def\outputheight{0}
            \draw[block arrow] (\gameedge, \outputheight) -- (\xmidtwo, \outputheight) node [msg, midway] {$\left(m^*,
                t^*\right)$};
                
        \end{scope}

        \draw[block arrow] (8.2, 2) -- (12, 2) node [msg, midway] {$\left(m, m ^ {*}\right)$};
    \end{tikzpicture}
\end{center}
        The collision finder $\mathcal{C}$ will \begin{itemize}
            \item On input $s$, sample $k \gets \widehat{Gen} \left(1^n\right)$, and invoke $\mathcal{A}$
            \item Respond to $\mathcal{A}$'s queries, using $\left(k, s\right)$
            \item If $\exists m \in \left\{m_1, \dots, m_1\right\}$ such that $m \ne m^*$, and $H_s \left(m\right) = H_s
                \left(m^*\right)$, then it will output $\left(m, m^*\right)$
            \item Otherwise it will output $\perp$ 
        \end{itemize}

        Proof of Claim II: \\ 
        Let us assume towards contradiction that there exists a PPT adversary $\mathcal{A}$, and a polynomial $p
        \left(n\right)$, such that  \[
            \Pr \left[MacForge_{\Phi, \mathcal{A}} \left(n\right)= 1 \land \overline{\text{collision}}\right] \geq
            \displaystyle\frac{1}{p \left(n\right)}
        \]
        for infinitely many $n$s. The forger $\widehat{\mathcal{A}}$ will \begin{itemize}
            \item Sample $s \gets Gen_H \left(1^n\right)$, and invoke $\mathcal{A}$
            \item Respond to $\mathcal{A}$'s queries $m_i$ by forwarding $H_s \left(m_i\right)$ to the oracle
                $\widehat{Mac}_k \left(\cdot\right)$, and then forwarding back its response to $\mathcal{A}$ 
            \item Output $\left(H_s \left(m^*\right), t^*\right)$
        \end{itemize}

        So \begin{align*}
            \Pr \left[MacForge_{\widehat{\Pi}, \widehat{\mathcal{A}}} \left(n\right) = 1\right] &= \Pr
            \left[MacForge_{\Pi, \mathcal{A}} \left(n\right) = 1 \land \overline{\text{collision}}\right] \\ 
                                                                                        &\geq \displaystyle\frac{1}{p
                                                                                        \left(n\right)}
        \end{align*}
        Which is a contradiction.
    \end{proof}
\end{theorem}
% section Authenticating Arbitrary-Length Messages (end)

\section{Returning to encryption}\label{sec:returning_to_encryption} % (fold)
Recall that CPA-secure encryptions may be built from any PRF, and hold that \[
    Enc_k \left(m; r\right) = \left(r, F_k \left(r\right) \oplus m\right)
\]
This has a rather serious problem. An adversary can change the contents of a message, without the recipient knowing. The
adversary will also not know how he has changed it, but he can change it, and none will know that this has happened. \[
    Enc_k \left(m \oplus 1^n; r\right) = \left(r, F_k \left(r\right) \oplus m \oplus 1^n\right)
\]
So, we want to achieve both encryption, and authenticated messages, creating \textbf{authenticated encryption}. 

Let us consider \begin{gather}
    k = \left(k_E, k_M\right) \\
    c \gets Enc_{k_E} \left(m\right) \\ 
    t \gets Mac_{k_M} \left(m, t\right)
\end{gather}
Which can then all be reversed \begin{gather}
    k = \left(k_E, k_M\right) \\
    m \gets Dec_{k_E} \left(c\right) \\ 
    ? \gets Mac_{k_M} \left(m, t\right)
\end{gather}
This may well be insecure. We have no guarantees that our MAC system does not leak information about the message. In
fact, we may completely leak $m$, since we have no security guarantees. 

This may be improved to
\begin{gather}
    k = \left(k_E, k_M\right) \\
    c \gets Enc_{k_E} \left(m\right) \\ 
    t \gets Mac_{k_M} \left(c, t\right)
\end{gather}
Which can then all be reversed \begin{gather}
    k = \left(k_E, k_M\right) \\
    m \gets Dec_{k_E} \left(c\right) \\ 
    ? \gets Mac_{k_M} \left(c, t\right)
\end{gather}
If the encryption is CPA-secure, and the MAC is secure, then this construction is a CPA-secure encryption scheme, with a
secure MAC. 

\subsection{Chosen Ciphertext Attack CCA}\label{sub:chosen_ciphertext_attack_cca} % (fold)
This has brought us to chosen ciphertext attack schemes. Here, $\mathcal{A}$ can adaptively ask for encryptions of
messages of its choice, and for decryptions of ciphertexts of its choice (aside from the challenge ciphertext $c^*$). 

\begin{definition}[CCA-IND]
    $\Pi$ has indistinguishable encryptions under a chosen-ciphertext attack if for every PPT adversary $\mathcal{A}$
    there exists a negligible function $v \left(\cdot\right)$ such that \[
        \Pr \left[IND_{\Pi, \mathcal{A}}^{CCA} \left(n\right) = 1\right] \leq \displaystyle\frac{1}{2} + v \left(n\right)
    \]
    In this case, we may also say that $\Pi$ is CCA-secure.
\end{definition}

We will observe that CCA-security implies authenticity. Given $Enc_k \left(m\right)$, it is hard to generate $Enc_k
\left(m'\right)$ for a \enquote{related} $m'$ (such as $m' = m + 1$). This is because if he could, then he could take
$c^*$, and flip the bits. This is (under the assumption) a legal encryption, which could then be decrypted into the
inverse bits of $m_b$, so he could then take the decryption of the inverse of $c^*$, flip its bits, and identify which
$m_i$ was returned encrypted to $c^*$. 

We will note that it feels a little unrealistic. Honest parties do not typically decrypt arbitrary adversarially chosen
ciphertexts. Nevertheless, adversaries may be able to influence what gets encrypted / decrypted, and learn some partial
information. For example, in WWII, the US cryptanalysts might have tried to send encrypted messages to the Japanese, and
then monitor their behaviour. An adversary may send certain ciphertexts on behalf of a user to the user's bank, and then
the bank will decrypt these ciphertexts and its response will leak information to the adversary. Furthermore, an
encryption scheme might be used as part of an authentication protocol where one party sends a ciphertext to the other,
who then decrypts it and returns the result. Thus we can see, that CCA is a realistic security requirement in the real
world. 

We will thus note that CPA security does \textbf{not} imply CCA security, since we can affect the output of encryption
function, and get another valid encryption: 
\begin{align*}
    Enc_k \left(m; r\right) &= \left(r, F_k \left(r\right) \oplus m \right) \\
    Enc_k \left(m \oplus 1^n; r\right) &= \left(r, F_k \left(r\right) \oplus m \oplus 1^n\right)
\end{align*}

\subsubsection{CCA-Secure encryption scheme}\label{sec:cca_secure_encryption_scheme} % (fold)
The main idea here is that adversaries should not be able to generate new \enquote{valid} ciphertexts, and that the
decryption oracle becomes useless. Our solution is called \textit{Encrypt-then-Authenticate}: \\ 
Let $\Pi_E = \left(KeyGen_E, Enc, Dec\right)$ be a CPA secure encryption scheme, and let $\Pi_M = \left(KeyGen_M, Enc,
Dec\right)$ be a secure MAC. Let us define $\Pi' = \left(KeyGen', Enc', Dec'\right)$ as \begin{itemize}
    \item $KeyGen' \left(1^n\right)$ output $k = \left(k_E, k_M\right)$ where $k_E \gets Gen_E \left(1^n\right)$ and
        $k_M \gets KeyGen_M \left(1^n\right)$
    \item $Enc_k' \left(m\right)$ output $\left(c, t\right)$ where $c \gets Enc_{k_E} \left(m\right)$ and $t \gets
        Mac_{k_M} \left(c\right)$
    \item $Dec_k' \left(c, t\right)$ If $Vrfy_{k_M} \left(c, t\right) = 1$ then output $Dec_{k_E} \left(c\right)$,
        otherwise output $\perp$ 
\end{itemize}

\begin{theorem}[]
    Let us assume that $\Pi_E$ is a CPA-secure encryption scheme, and that $\Pi_M$ is a secure MAC with \textbf{unique
    tags}, then $\Pi'$ is a CCA secure encryption scheme. 
    \begin{proof}[Proof ]
        We will first note that MAC with unique tags means that for any key $k_M$ and message $m$, there exists
        \textit{exactly} one $t$ such that $Vrfy_{k_M} \left(m, t\right) = 1$. Any MAC scheme with a deterministic Mac
        algorithm can be modified to have unique tags by using \enquote{canonical verification} instead of its own Vrfy
        algorithm: On input $\left(k_M, m, t\right)$ output 1 if and only if $t = Mac_{k_M} \left(m\right)$ and 0 otherwise

        \textbf{Proof idea}: \\
        We will call $\left(c, t\right)$ valid w.r.t $\left(k_E, k_M\right)$ if $Vrfy_{k_M} \left(c, t\right) = 1$, and
        invalid otherwise. Consider the event ValidQuery. $\mathcal{A}$ queries the decryption oracle with a valid
        ciphertext, that was \textbf{not} produced by the encryption oracle. If $\Pr \left[ValidQuery\right]$ is
        non-negligible, then we can use $\mathcal{A}$ to break the MAC $\Pi_M$. If it is negligible, then we can use
        $\mathcal{A}$ to break the CPA security of $\Pi_E$

        Let $\mathcal{A}$ be a PPT adversary, then: \begin{gather}
            \Pr \left[IND_{\Pi', \mathcal{A}} ^ {CCA} \left(n\right) = 1\right] \\ 
            \leq \Pr \left[ValidQuery\right] + \Pr \left[IND_{\Pi', \mathcal{A}} ^ {CCA} \left(n\right) = 1 \land
            \overline{ValidQuery}\right]
        \end{gather}

        \begin{theorem}[Claim II]
            \textbf{Claim II}: There exists a negligible $v \left(n\right)$ such that \[
                \Pr \left[IND_{\Pi', \mathcal{A}} ^ {CCA} \left(n\right) = 1 \land \overline{ValidQuery}\right] \leq
                \displaystyle\frac{1}{2} + v \left(n\right)
            \]
            \begin{proof}[Proof ]
                We will assume towards contradiction that there exists a polynomial $p \left(n\right)$, such that for
                infinitely many $n$s \[
                    \Pr \left[IND_{\Pi', \mathcal{A}} ^ {CCA} \left(n\right) = 1 \land \overline{ValidQuery}\right] \geq
                    \displaystyle\frac{1}{2} + \displaystyle\frac{1}{p \left(n\right)}
                \]
                We will construct an adversary $\mathcal{B}$ such that for infinitely many $n$s \[
                    \Pr \left[IND_{\Pi_E, \mathcal{B}} ^ {CCA} \left(n\right) = 1 \land \overline{ValidQuery}\right] \geq
                    \displaystyle\frac{1}{2} + \displaystyle\frac{1}{p \left(n\right)}
                \]
                $\mathcal{B}$ will sample $k_M$, and invoke $\mathcal{A}$, and respond to its queries. It will then
                output the same $\left(m_0, m_1\right)$, and $b'$. \\
                It will query the oracle $Enc_{k_E} \left(\cdot\right)$ to obtain a ciphertext $c$, compute $t \gets
                Mac_{k_M} \left(c\right)$, and return $\left(c, t\right)$. \\
                For the decryption query, if $\left(c, t\right)$ was a response to a previous query $m$, then return
                $m$, and otherwise return $\perp$.

                Since ValidQuery does not occur, then $\mathcal{B}$ does not need a decryption oracle for simulating
                $\mathcal{A}$'s view. Thus: \begin{gather}
                    \Pr \left[IND_{\Pi_E, \mathcal{B}} ^ {CPA} \left(n\right) = 1\right] \\ 
                    \geq \Pr \left[IND_{\Pi_E, \mathcal{B}} ^ {CPA} \left(n\right) \land \overline{ValidQuery}\right] \\
                    = \Pr \left[IND_{\Pi_E, \mathcal{A}} ^ {CPA} \left(n\right) \land \overline{ValidQuery}\right] \\
                    \geq \displaystyle\frac{1}{2} + \displaystyle\frac{1}{p \left(n\right)}
                \end{gather}
            \end{proof}
        \end{theorem}

        \begin{theorem}[Claim I]
            \textbf{Claim I}: There exists a negligible $v \left(n\right)$ such that $\Pr \left[ValidQuery\right] \leq v
            \left(n\right)$
            
            \begin{proof}[Proof ]
                Let us assume towards contradiction that there exists a polynomial $p \left(n\right)$ such that $\Pr
                \left[ValidQuery\right] \geq \displaystyle\frac{1}{p \left(n\right)}$ for infinitely many $n$'s. Let $q
                \left(n\right)$ be a polynomial upper bound on the number of decryption queries made by $\mathcal{A}$.
                We will construct a PPT adversary $\mathcal{B}$ such that $\Pr \left[MacForge_{\Pi_M, \mathcal{B}} =
                1\right] \geq \displaystyle\frac{1}{p \left(n\right) \cdot q \left(n\right)}$ for infinitely many $n$s

                We will construct $\mathcal{B}$ as follows: Sample $k_E, b$ and $i \gets \left\{1, \dots, q\right\}$,
                invoke $\mathcal{A}$, and respond to its queries. For an encryption query $m$, we will compute $c \gets
                Enc_{k_E} \left(m\right)$, and query the oracle $Mac_{k_M} \left(\cdot\right)$ with $c$ to obtain the
                tag $t$. Finally, return $\left(c, t\right)$. \\
                For the first $i - 1$ decryption queries $\left(c, t\right)$, if $\left(c, t\right)$ was a response to a
                previous encryption query $m$, then return $m$, and otherwise $\perp$. For the $i$th decryption query
                $\left(c, t\right)$, output $\left(c^*, t^*\right)  =\left(c, t\right)$ as the (potential) forgery.

                We will observe that ValidQuery occurs, and that $\mathcal{B}$ guesses the index $i$ of the first valid
                decryption query that was not obtained from a previous encryption query. Therefore, $Vrfy_{k_M}
                \left(c^*, t^*\right) = 1$ and $\mathcal{B}$ did not query $Mac_{k_M} \left(\cdot\right)$ on $c^*$. So,
                we may conclude \begin{align*}
                    \Pr \left[MacForge_{\Pi_M, \mathcal{B}} = 1\right] &\geq \Pr \left[ValidQuery \land \mathcal{B}
                    \text{ guesses } i\right] \\ 
                                                                       &= \displaystyle\frac{\Pr
                                                                       \left[ValidQuery\right]}{q \left(n\right)} \\ 
                                                                       &\geq \displaystyle\frac{1}{p \left(n\right)
                                                                       \cdot q \left(n\right)}
                \end{align*}
            \end{proof}
        \end{theorem}
    \end{proof}
\end{theorem}
% subsubsection CCA-Secure encryption scheme (end)
% subsection Chosen Ciphertext Attack CCA (end)
% section Returning to encryption (end)

\section{Crypto primitives so far}\label{sec:crypto_primitives_so_far} % (fold)
So far, we have seen PRFs, PRGs, built PRGs from PRFs. From PRGs we have create IND-secure symmetric key encryption,
and built CPA-secure symmetric key encryption from PRFs. Furthermore, we built IND-secure from CPA-secure. PRFs were also
used to create MACs for fixed length messages, we then combined fixed length MAC and CPA-secure to make CCA secure
symmetric key encryption. Finally, from MAC for fixed length messages, and Collision Resistant Hash Function, we made
MAC for arbitrary length messages. 

This concludes this section of the course, covering symmetric encryption. 
% section Crypto primitives so far (end)

\end{document}
