\documentclass[a4paper]{article}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{blindtext}
\usepackage{multicol}
\usepackage{graphicx}
\usepackage{placeins}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{booktabs}
\usepackage{float}
\usepackage[bookmarks=true]{hyperref}
\usepackage{bookmark}
\usepackage{bbm}
\usepackage{wrapfig}
\usepackage{tabularx}
\usepackage[autostyle=true]{csquotes}
\graphicspath{ {./images/} }
\usepackage[bottom=0.5cm, right=1.5cm, left=1.5cm, top=1.5cm]{geometry}

\newtheorem{theorem}{Theorem}
\newtheorem{exercise}{Exercise}
\newtheorem{example}{Example}
\newtheorem{definition}{Definition}[section]

\newcommand{\R}{\ensuremath{\mathbb{R}}}
\newcommand{\N}{\ensuremath{\mathbb{N}}}
\newcommand{\Z}{\ensuremath{\mathbb{Z}}}
\newcommand{\p}{\ensuremath{\mathbb{P}}}
\newcommand{\E}{\ensuremath{\mathbb{E}}}
\newcommand{\F}{\ensuremath{\mathcal{F}}}
\newcommand{\1}{\ensuremath{\mathbbm{1}}}
\newcommand{\G}{\ensuremath{\mathbbm{G}}}

\title{Lecture 7 - Public key encryption}
\author{Gidon Rosalki}
\date{2025-12-17}


\begin{document}
\maketitle
\noindent\textbf{Notice:} If you find any mistakes, please open an issue at \href{https://github.com/robomarvin1501/notes\_intro\_to\_crypto}{\texttt{https://github.com/robomarvin1501/notes\_intro\_to\_crypto}}
\section{Public key encryption}\label{sec:public_key_encryption} % (fold)

\subsection{Definitions}\label{sub:definitions} % (fold)
Public key encryption involves the following syntax: There are three algorithms $\Pi = \left(KeyGen, Enc, Dec\right)$:
\begin{itemize}
    \item The key generation algorithm $KeyGen \left(1 ^ {n}\right)$ outputs a secret key $sk$, and a public key $pk$ 
    \item Encryption algorithm $Enc$ takes a public key $pk$ and a plaintext $m$, and outputs a ciphertext $c$
    \item Decryption algorithm $Dec$ takes a secret key $sk$ and a ciphertext $c$, and outputs a plaintext $m$
\end{itemize}
It is correct if for every $m \in \mathcal{M}$ \[
    \Pr \left[Dec_{sk} \left(Enc_{pk} \left(m\right)\right) = m\right] = 1
\]

\begin{definition}[IND-CPA]
    $\Pi$ has indistinguishable encryptions under a chosen-plaintext attack if for every PPT adversary $\mathcal{A}$
    there exists a negligible function $v \left(\cdot\right)$ such that \[
        \Pr \left[IND_{\Pi, \mathcal{A}}^{CPA} \left(n\right) = 1\right] \leq \displaystyle\frac{1}{2} + v \left(n\right)
    \]
\end{definition}

So here the game is subtly different. Recall that the game is that $\mathcal{A}$ receives the encryption algorithm,
produces two plaintexts, receive the encryption of one of them, and has to guess which one. Now, instead of the
encryption algorithm, it receives the public key. There is no need to provide an encryption oracle, since $\mathcal{A}$
can encrypt by itself using the public key. However, one \textbf{must} use a randomised encryption, to avoid
$\mathcal{A}$ just encrypting $m_0, m_1$ by itself. In comparison, for CCA $\mathcal{A}$ can also access a decryption
oracle (aside from for $c ^ {*}$).
% subsection Definitions (end)

\subsection{Encrypting long messages}\label{sub:encrypting_long_messages} % (fold)
So we need to encrypt long messages. This can be done by encrypting them in blocks: \[
    Enc_{pk}' \left(m ^ {\left(1\right)} \dots m ^ {p \left(n\right)}\right) = \left(Enc_{pk} \left(m ^
    {\left(1\right)}\right), \dots, Enc_{pk} \left(m ^ {p \left(n\right)}\right)\right)
\]
\begin{theorem}[]
    If $\Pi = \left(KeyGen, Enc, Dec\right)$ is CPA secure, then for any polynomial $p \left(n\right)$ the scheme $\Pi'
    = \left(KeyGen, Enc', Dec'\right)$ is CPA secure

    \begin{proof}[Proof Idea]
        Given an adversary $\mathcal{A}'$ for $\Pi'$, construct an adversary $\mathcal{A}$ for $\Pi$. $\mathcal{A}$ gets
        one challenge ciphertext, and generates the others on its own.
        \begin{figure}[H]
            \center
            \includegraphics[scale=0.2]{lecture_7_public_hybrid.png}
            \caption{Hybrid argument}
        \end{figure}
        
        So $\mathcal{A}$ can generate the messages $\left(m_0 ^ {\left(1\right)}, m_0 ^ {\left(2\right)}\right)$, and
        $\left(m_1 ^ {\left(1\right)}, m_1 ^ {\left(2\right)}\right)$, and mix the two halves. It can then (for example)
        provide $\left(m_0 ^ {\left(1\right)}, m_0 ^ {\left(2\right)}\right)$ and $\left(m_0 ^ {\left(1\right)}, m_1 ^
        {\left(2\right)}\right)$, with an advantage of at least $\displaystyle\frac{\varepsilon}{2}$. Since it can
        differentiate between the halves, it is then able to differentiate between the messages.
    \end{proof}
\end{theorem}

Now, public key schemes are somewhat inefficient, and slow to compute, but symmetric (private key) schemes are much
faster. The solution is called \textbf{Hybrid encryption}, where one generates a \textit{session key} $k$, encrypts it
(since it is short) with a public key encryption scheme, and then encrypt $m$ with a private key scheme, using $k$ as
the key.

% subsection Encrypting long messages (end)
% section Public key encryption (end)

\section{Hybrid encryption}\label{sec:hybrid_encryption} % (fold)
\begin{definition}[Hybrid encryption]
    Let $\Pi = \left(KeyGen, Enc, Dec\right)$ be a public key encryption scheme, and let $\left(E, D\right)$ be a
    symmetric key encryption scheme. We can now define a public key encryption scheme $\Pi' = \left(Gen', Enc',
    Dec'\right)$ , where \begin{itemize}
        \item $Gen' = Gen$
        \item $Enc_{pk}' \left(m\right)$ samples $k \gets \left\{0, 1\right\} ^ {n}$, computes $c_1 \gets Enc_{pk}
            \left(k\right)$, and $c_2 \gets E_k \left(m\right)$. It outputs $c - \left(c_1, c_2\right)$
        \item $Dec_{sk}' \left(c_1, c_"\right)$: Compute $k \gets Dec_{sk} \left(c_1\right)$, and output $D_k
            \left(c_2\right)$
    \end{itemize}
\end{definition}

\begin{theorem}[]
    If $\Pi$ is CPA-secure, and $\left(E, D\right)$ is IND-secure, then $\Pi'$ is CPA secure

    \begin{proof}[Proof ]
        Let there be $\mathcal{A}'$ for $\Pi'$. It receives $pk$, outputs $m_0, m_1$, receives $Enc_{pk} \left(k\right),
        E_k \left(m_b\right)$, and outputs $b'$. From this we may construct an adversary $\mathcal{A}$ for $\Pi$, or an
        adversary $\mathcal{B}$ for $\left(E, D\right)$. Taking the two messages that $\mathcal{A}'$ outputs, $m_0',
        m_1'$, then we may consider the following: \begin{enumerate}
            \item $\left(Enc_{pk} \left(k\right), E_k \left(m_0'\right)\right)$
            \item $\left(Enc_{pk} \left(0 ^ {n}\right), E_k \left(m_0'\right)\right)$
            \item $\left(Enc_{pk} \left(0 ^ {n}\right), E_k \left(m_1'\right)\right)$
            \item $\left(Enc_{pk} \left(k\right), E_k \left(m_1'\right)\right)$
        \end{enumerate}
        From 1 - 4 $\mathcal{A}'$ let us say that $\mathcal{A}'$ has the advantage $\varepsilon$. As a result, there are
        2 stages where it has an advantage of at least $\displaystyle\frac{\varepsilon}{3}$. We can now build
        $\mathcal{A}$, that simulates $\mathcal{A}'$. Upon receiving $m_0', m_1'$, we will output \begin{gather*}
            m_0 = k \\
            m_1 = 0 ^ {n}
        \end{gather*}
        and receive in return the public key encryption of one of them $c^* = Enc_{pk} \left(m_b\right)$. We can then
        then return $\left(c^*, E_k \left(m_0'\right)\right)$ to $\mathcal{A}'$, which will output the correct $b'$ with
        its advantage, since it can differentiate between $Enc_{pk} \left(k\right)$ and $Enc_{pk} \left(0 ^ {n}\right)$. \\
        Conversely, if we set \begin{gather}
            m_0 = m_0'
            m_1 = m_1'
        \end{gather}
        Then we can give $\mathcal{A}'$ the input $\left(Enc_{pk} \left(0 ^ {n}\right), c^*\right)$, where $c^* = E_k
        \left(m_b\right)$, and since it has the advantage for $E_k \left(m_0'\right)$ and $E_k \left(m_1'\right)$, we
        will once again get back the correct $b'$. \\ 
        Finally, we can also have $\mathcal{A}$ output \begin{gather*}
            m_0 = 0 ^ {n} \\ 
            m_1 = k
        \end{gather*}
        Receiving back $c^* = Enc_{pk} \left(m_b\right)$, give $\left(c^*, E_k \left(m_1'\right)\right)$ to
        $\mathcal{A}'$, and thanks to the advantage that $\mathcal{A}'s$ has between $Enc_{pk} \left(0 ^ {n}\right)$ and
        $Enc_{pk} \left(k\right)$, it will return the correct $b'$.
    \end{proof}
\end{theorem}

\subsection{El-Gamal Encryption}\label{sub:el_gamal_encryption} % (fold)
Behold a real public key encryption scheme. It is based on Diffie-Hellman key agreement, and relies on the DDH
assumption. Recall the DDH assumption: Let $\mathcal{G}$ be a PPT algorithm that on input $1 ^ {n}$, outputs $\left(\G, q, g\right)$, where $\G$ is a cyclic
group of order $q$, that is generated by $g$, and $q$ is an $n$bit prime.
\begin{definition}[The Decisional Diffie Hellman (DDH) Assumption]
    For every PPT algoirithm $\mathcal{A}$ there exists a negligible function $v \left(\cdot\right)$ such that \[
        \left|\Pr \left[\mathcal{A} \left(\G, q, g, g ^ {x}, g ^ {y}, g ^ {xz}\right) = 1\right] - \Pr \left[\mathcal{A}
        \left(\G, q, g, g ^ {x}, g ^ {y}, g ^ {z}\right) = 1\right]\right| \leq v \left(n\right)
    \]
    Where $\left(\G, q, g\right) \gets \mathcal{G} \left(1 ^ {n}\right)$, and $x, y, z \gets \Z_q$
\end{definition}

So: Let $\mathcal{G}$ be a PPT algorithm that on input $1 ^ {n}$ outputs $\left(\G, q, g\right)$, where $\G$ is a cyclic
group of order $q$, that is generated by $g$. We will define a public key encryption scheme $\Pi = \left(KeyGen, Enc,
Dec\right)$ as \begin{itemize}
    \item $Gen' \left(1 ^ {n}\right)$: Sample $\left(\G, q, g\right) \gets \mathcal{G} \left(1 ^ {n}\right)$, and $x
        \gets \Z_q$. Let $h = g ^ {x}$, and output $pk = \left(\G, q, g, h\right)$, and $sk = x$
    \item $Enc_{pk} \left(m\right)$: Sample $y \gets \Z_q$, and output $c = \left(g ^ {y}, h ^ {y} \cdot m\right)$
    \item $Dec_{sk} \left(c_1, c_2\right)$: Output $m = \displaystyle\frac{c_2}{c_1 ^ {x}}$
\end{itemize}
Note that there are methods for encoding binary strings as group elements, and that for simplicity, we assume that the
plaintext set is $\G$. 
\[
    Dec_{sk} \left(Enc_{pk} \left(m\right)\right) = Dec_{sk} \left(g ^ {y}, h ^ {y} \cdot m\right) =
    \displaystyle\frac{h ^ {y} \cdot m}{\left(g ^ {y}\right) to x} = \displaystyle\frac{\left(g ^ {x}\right) ^ {y} \cdot
    m}{\left(g ^ {y}\right) ^ {x}} = m
\]

\begin{theorem}[Security]
    Under the DDH assumption, the scheme $\Pi$ is secure

    \begin{proof}[Proof ]
        Hey look! Another reduction. We will assume that there exists $\mathcal{A}$ that breaks $\Pi$, and so we can
        build $\mathcal{D}$ that breaks DDH. So, $\mathcal{D}$ receives $\left(g ^ {x}, g ^ {y}, g ^ {z}\right)$, and
        needs to return if $z = xy$, or if $z$ is random. \\ 

        Let us construct $\mathcal{D}$, that receives $\left(\G, q, g, g_1, g_2, g_3\right)$. It will give $\mathcal{A}$
        $pk = \left(\G, q, g, g_1\right)$. $\mathcal{A}$ will return $m_0, m_1$, and then $\mathcal{D}$ will return to
        $\mathcal{A}$ the ciphertext $c^* = \left(g_2, g_3 \cdot m_b\right)$. \\ 

        \textbf{Case I}: \[
            \left(g, g_1, g_2, g_3\right) = \left(g, g ^ {x}, g ^ {y}, g ^ {xy}\right)
        \]
        Here, $\mathcal{A}$'s view is identical to the CPA experiment, and therefore \[
            \Pr \left[\mathcal{D} \left(\G, q, g, g ^ {x}, g ^ {y}, g ^ {xy}\right) = 1\right] = \Pr \left[IND_{\Pi,
            \mathcal{A}}^{CPA} \left(n\right) = 1\right]
        \]

        \textbf{Case II}: Let $z$ be a random number, of appropriate size: \[
            \left(g, g_1, g_2, g_3\right) = \left(g, g ^ {x}, g ^ {y}, g ^ {z}\right)
        \]
        The view of $\mathcal{A}$ is independent of the bit $b$, and so \[
            \Pr \left[\mathcal{D} \left(\G, q, g, g ^ {x}, g ^ {y}, g ^ {z}\right) = 1\right] = \displaystyle\frac{1}{2}
        \]

        So, given $\left(\G, q, g, g_1, g_2, g_3\right)$, our algorithm $\mathcal{D}$ will generate $pk = \left(\G, q,
        g, g_1\right)$, and upon $\mathcal{A}$ response of $m_0, m_1$, it will return $c^* = \left(g_2, g_3 \cdot
        m_b\right)$. It will take $\mathcal{A}$'s output $b'$, and output 1 if $b' = b$, and 0 otherwise. By the DDH
        assumption: \begin{align*}
            v \left(n\right) &\geq \left|\Pr \left[\mathcal{D} \left(\G, q, g, g ^ {x}, g^y, g ^ {xy}\right) = 1\right] -
            \Pr \left[\mathcal{D} \left(\G, q, g, g ^ {x}, g ^ {y}, g ^ {z}\right) = 1\right]\right| \\ 
                             &= \left|\Pr \left[IND_{\Pi, \mathcal{A}}^{CPA} \left(n\right) = 1\right] -
                             \displaystyle\frac{1}{2}\right|
        \end{align*}
    \end{proof}
\end{theorem}

% subsection El-Gamal Encryption (end)

\subsection{RSA encryption}\label{sub:rsa_encryption} % (fold)
\subsubsection{The RSA assumption}\label{sec:the_rsa_assumption} % (fold)
Let GenRSA be a PPT algorithm that on input $1 ^ {n}$ outputs $\left(N, e, d\right)$, where $p, q$ are $n$ bit primes,
$N = pq$, $gcd \left(e, \phi \left(N\right)\right) = 1$, and $d = e ^ {-1} \mod \phi \left(N\right)$. Here
$\phi \left(N\right)$ is the order of our set $\Z_{N = pq} ^ {*}$, such that $\phi \left(N\right) = \left(p -
1\right) \left(q - 1\right)$. 

\begin{definition}[RSA Assumption]
    For every PPT $\mathcal{A}$ there exists a negligible function $v \left(\cdot\right)$ such that \[
        \Pr \left[\mathcal{A} \left(N, e, x ^ {e} \mod N\right) = x\right] \leq v \left(n\right)
    \]
    Where $\left(N, e, d\right) \gets GenRSA \left(1 ^ {n}\right)$ and $x \gets \Z_N ^ {*}$. 
\end{definition}
In short, given $x ^ {e} \mod N$, it is very hard to compute $x$. In other words, $f_e \left(x\right) = x ^ {e} \mod N$
is a one way permutation family. $f_d$ is the inverse of $f_e$, since $ed = 1 \mod \phi \left(N\right)$
% subsubsection The RSA assumption (end)

\subsubsection{Textbook RSA encryption}\label{sec:textbook_rsa_encryption} % (fold)
Let GenRSA be a PPT algorithm that on input $1 ^ {n}$ outputs $\left(N, e, d\right)$, where $p, q$ are $n$ bit primes,
$N = pq$, $gcd \left(e, \phi \left(N\right)\right) = 1$, and $d = e ^ {-1} \mod \phi \left(N\right)$.

From here we create the public key $pk = \left(N, e\right)$, and the private key $sk = d$. Thus: \begin{gather}
    Enc_{pk} \left(m\right) = m ^ {e} \mod N \\ 
    Dec_{sk} \left(c\right) = c ^ {d} \mod N
\end{gather}
This is... Not a great system to be honest. It was first suggested in 1977, but the security definitions, like
CPA-security were created in 1982. We may firstly note that Enc is deterministic, which is immediately \textbf{bad}. We
will note that it is also not CPA-secure, many attacks are known. For example, if $m ^ {e} < N$, then $c = \left[m ^ {e}
\mod N\right] = m ^ {e}$, and so $c ^ {\frac{1}{e}} = m$. \\ 

We may take this moment to state \textbf{NEVER USE TEXTBOOK RSA!!!} \\ 
To emphasise this point I have used atrocious grammar. I hope this helps you remember this. \\ 
(There is in fact an argument, which I will link
\href{https://blog.trailofbits.com/2019/07/08/fuck-rsa/}{\texttt{here}}, that RSA should never be used. It is not a part
of the course, and I have added it purely for your own interest.)
% subsubsection Textbook RSA encryption (end)

\subsubsection{PKCS}\label{sec:pkcs} % (fold)
Version 1.5 was standard issued by RSA labs in 1993. The idea is random padding: \begin{gather}
    pk = \left(N, e\right) \\ 
    sk = d
\end{gather}
So, $Enc_{pk} \left(m\right) = \left(r \| m\right) ^ {e} \mod N$, for a freshly chosen random $r$. This has the
drawbacks that no proof of CPA security exists (aside from if $m$ is very short). Chosen plaintext attacks are known if
$r$ is too short, and chosen ciphertext attacks are also known. In short, we do not know if it is secure, nor do we even
have a neat little assumption (like DDH) that \textit{if} it holds, we know it to be secure.

Next is version 2.0, which uses a more structured padding: Optimal Asymmetric Encryption Padding (OAEP). OAEP introduces
redundancy, so that not every $c \in \Z_n^*$ is a valid ciphertext. This means that $Dec_{sk} \left(\cdot\right)$ must
check for proper formatting upon decryption, and reject if it does not exist. This can be proved to be CCA-secure under
the RSA assumption, if $G$ and $H$ are modelled as \enquote{random} hash functions. It is widely used in practice. 
\begin{figure}[H]
    \center
    \includegraphics[scale=0.2]{lecture_7_pkcs2.png}
    \caption{}
\end{figure}

Note that the RSA permutation family is \textbf{not} a CPA-secure PKE scheme. It is however a family of \textit{trapdoor
permutations}, which are one way permutations that may be efficiently inverted using a trapdoor. We will show a generic
construction of a CPA secure scheme from any TDP (trapdoor permutation) family: 
\begin{definition}[Trapdoor permutation family]
    A tuple $\left(\text{Gen}, \text{Samp}, f, f ^ {-1}\right)$ of PPT algorithms is a \textbf{trapdoor permutation
    family} if: \begin{itemize}
        \item Gen $\left(1 ^ {n}\right)$ outputs pairs $\left(I, td\right)$ defining a domain $\mathcal{D}_I$
        \item $\left(\text{Gen}_1, \text{Samp}, f\right)$ is a one way permutation family, where $\text{Gen}_1$ is
            obtained from Gen by outputting only $I$
        \item $f ^ {-1}$ is deterministic, and for all $\left(I, td\right)$ and $x \in \mathcal{D}_I$ it holds that
            $f_{td} ^ {-1} \left(f_I \left(x\right)\right) = x$
    \end{itemize}
\end{definition}
For simplicity, we will typically write $x \gets \mathcal{D}_I$ instead of $x \gets \text{Samp}_I$, and $\left(Gen, f, f
^ {-1}\right)$ instead of $\left(\text{Gen}, \text{Samp}, f, f ^ {-1}\right)$.
% subsubsection PKCS (end)
% subsection RSA encryption (end)

% section Hybrid encryption (end)

To summarise our cryptographic primitives once more: \begin{figure}[H]
    \center
    \includegraphics[scale=0.2]{lecture_7_crypto_primitives_end.png}
    \caption{Cryptographic primitives}
\end{figure}


\section{Constructions}\label{sec:constructions} % (fold)
% TODO From el gamal to the end should be in constructions
% section Constructions (end)

\end{document}
