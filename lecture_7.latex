\documentclass[a4paper]{article}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{blindtext}
\usepackage{multicol}
\usepackage{graphicx}
\usepackage{placeins}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{booktabs}
\usepackage{float}
\usepackage[bookmarks=true]{hyperref}
\usepackage{bookmark}
\usepackage{bbm}
\usepackage{wrapfig}
\usepackage{tabularx}
\usepackage[autostyle=true]{csquotes}
\graphicspath{ {./images/} }
\usepackage[bottom=0.5cm, right=1.5cm, left=1.5cm, top=1.5cm]{geometry}

\newtheorem{theorem}{Theorem}
\newtheorem{exercise}{Exercise}
\newtheorem{example}{Example}
\newtheorem{definition}{Definition}[section]

\newcommand{\R}{\ensuremath{\mathbb{R}}}
\newcommand{\N}{\ensuremath{\mathbb{N}}}
\newcommand{\Z}{\ensuremath{\mathbb{Z}}}
\newcommand{\p}{\ensuremath{\mathbb{P}}}
\newcommand{\E}{\ensuremath{\mathbb{E}}}
\newcommand{\F}{\ensuremath{\mathcal{F}}}
\newcommand{\1}{\ensuremath{\mathbbm{1}}}
\newcommand{\G}{\ensuremath{\mathbbm{G}}}

\title{Lecture 7 - Public key encryption}
\author{Gidon Rosalki}
\date{2025-12-17}


\begin{document}
\maketitle
\noindent\textbf{Notice:} If you find any mistakes, please open an issue at \href{https://github.com/robomarvin1501/notes\_intro\_to\_crypto}{\texttt{https://github.com/robomarvin1501/notes\_intro\_to\_crypto}}
\section{Public key encryption}\label{sec:public_key_encryption} % (fold)

\subsection{Definitions}\label{sub:definitions} % (fold)
Public key encryption involves the following syntax: There are three algorithms $\Pi = \left(KeyGen, Enc, Dec\right)$:
\begin{itemize}
    \item The key generation algorithm $KeyGen \left(1 ^ {n}\right)$ outputs a secret key $sk$, and a public key $pk$ 
    \item Encryption algorithm $Enc$ takes a public key $pk$ and a plaintext $m$, and outputs a ciphertext $c$
    \item Decryption algorithm $Dec$ takes a secret key $sk$ and a ciphertext $c$, and outputs a plaintext $m$
\end{itemize}
It is correct if for every $m \in \mathcal{M}$ \[
    \Pr \left[Dec_{sk} \left(Enc_{pk} \left(m\right)\right) = m\right] = 1
\]

\begin{definition}[IND-CPA]
    $\Pi$ has indistinguishable encryptions under a chosen-plaintext attack if for every PPT adversary $\mathcal{A}$
    there exists a negligible function $v \left(\cdot\right)$ such that \[
        \Pr \left[IND_{\Pi, \mathcal{A}}^{CPA} \left(n\right) = 1\right] \leq \displaystyle\frac{1}{2} + v \left(n\right)
    \]
\end{definition}

So here the game is subtly different. Recall that the game is that $\mathcal{A}$ receives the encryption algorithm,
produces two plaintexts, receive the encryption of one of them, and has to guess which one. Now, instead of the
encryption algorithm, it receives the public key. There is no need to provide an encryption oracle, since $\mathcal{A}$
can encrypt by itself using the public key. However, one \textbf{must} use a randomised encryption, to avoid
$\mathcal{A}$ just encrypting $m_0, m_1$ by itself. In comparison, for CCA $\mathcal{A}$ can also access a decryption
oracle (aside from for $c ^ {*}$).
% subsection Definitions (end)

\subsection{Encrypting long messages}\label{sub:encrypting_long_messages} % (fold)
So we need to encrypt long messages. This can be done by encrypting them in blocks: \[
    Enc_{pk}' \left(m ^ {\left(1\right)} \dots m ^ {p \left(n\right)}\right) = \left(Enc_{pk} \left(m ^
    {\left(1\right)}\right), \dots, Enc_{pk} \left(m ^ {p \left(n\right)}\right)\right)
\]
\begin{theorem}[]
    If $\Pi = \left(KeyGen, Enc, Dec\right)$ is CPA secure, then for any polynomial $p \left(n\right)$ the scheme $\Pi'
    = \left(KeyGen, Enc', Dec'\right)$ is CPA secure

    \begin{proof}[Proof Idea]
        Given an adversary $\mathcal{A}'$ for $\Pi'$, construct an adversary $\mathcal{A}$ for $\Pi$. $\mathcal{A}$ gets
        one challenge ciphertext, and generates the others on its own.
        \begin{figure}[H]
            \center
            \includegraphics[scale=0.2]{lecture_7_public_hybrid.png}
            \caption{Hybrid argument}
        \end{figure}
        
        So $\mathcal{A}$ can generate the messages $\left(m_0 ^ {\left(1\right)}, m_0 ^ {\left(2\right)}\right)$, and
        $\left(m_1 ^ {\left(1\right)}, m_1 ^ {\left(2\right)}\right)$, and mix the two halves. It can then (for example)
        provide $\left(m_0 ^ {\left(1\right)}, m_0 ^ {\left(2\right)}\right)$ and $\left(m_0 ^ {\left(1\right)}, m_1 ^
        {\left(2\right)}\right)$, with an advantage of at least $\displaystyle\frac{\varepsilon}{2}$. Since it can
        differentiate between the halves, it is then able to differentiate between the messages.
    \end{proof}
\end{theorem}

Now, public key schemes are somewhat inefficient, and slow to compute, but symmetric (private key) schemes are much
faster. The solution is called \textbf{Hybrid encryption}, where one generates a \textit{session key} $k$, encrypts it
(since it is short) with a public key encryption scheme, and then encrypt $m$ with a private key scheme, using $k$ as
the key.

% subsection Encrypting long messages (end)
% section Public key encryption (end)

\section{Hybrid encryption}\label{sec:hybrid_encryption} % (fold)
\begin{definition}[Hybrid encryption]
    Let $\Pi = \left(KeyGen, Enc, Dec\right)$ be a public key encryption scheme, and let $\left(E, D\right)$ be a
    symmetric key encryption scheme. We can now define a public key encryption scheme $\Pi' = \left(Gen', Enc',
    Dec'\right)$ , where \begin{itemize}
        \item $Gen' = Gen$
        \item $Enc_{pk}' \left(m\right)$ samples $k \gets \left\{0, 1\right\} ^ {n}$, computes $c_1 \gets Enc_{pk}
            \left(k\right)$, and $c_2 \gets E_k \left(m\right)$. It outputs $c - \left(c_1, c_2\right)$
        \item $Dec_{sk}' \left(c_1, c_"\right)$: Compute $k \gets Dec_{sk} \left(c_1\right)$, and output $D_k
            \left(c_2\right)$
    \end{itemize}
\end{definition}

\begin{theorem}[]
    If $\Pi$ is CPA-secure, and $\left(E, D\right)$ is IND-secure, then $\Pi'$ is CPA secure

    \begin{proof}[Proof ]
        Let there be $\mathcal{A}'$ for $\Pi'$. It receives $pk$, outputs $m_0, m_1$, receives $Enc_{pk} \left(k\right),
        E_k \left(m_b\right)$, and outputs $b'$. From this we may construct an adversary $\mathcal{A}$ for $\Pi$, or an
        adversary $\mathcal{B}$ for $\left(E, D\right)$. Taking the two messages that $\mathcal{A}'$ outputs, $m_0',
        m_1'$, then we may consider the following: \begin{enumerate}
            \item $\left(Enc_{pk} \left(k\right), E_k \left(m_0'\right)\right)$
            \item $\left(Enc_{pk} \left(0 ^ {n}\right), E_k \left(m_0'\right)\right)$
            \item $\left(Enc_{pk} \left(0 ^ {n}\right), E_k \left(m_1'\right)\right)$
            \item $\left(Enc_{pk} \left(k\right), E_k \left(m_1'\right)\right)$
        \end{enumerate}
        From 1 - 4 $\mathcal{A}'$ let us say that $\mathcal{A}'$ has the advantage $\varepsilon$. As a result, there are
        2 stages where it has an advantage of at least $\displaystyle\frac{\varepsilon}{3}$. We can now build
        $\mathcal{A}$, that simulates $\mathcal{A}'$. Upon receiving $m_0', m_1'$, we will output \begin{gather*}
            m_0 = k \\
            m_1 = 0 ^ {n}
        \end{gather*}
        and receive in return the public key encryption of one of them $c^* = Enc_{pk} \left(m_b\right)$. We can then
        then return $\left(c^*, E_k \left(m_0'\right)\right)$ to $\mathcal{A}'$, which will output the correct $b'$ with
        its advantage, since it can differentiate between $Enc_{pk} \left(k\right)$ and $Enc_{pk} \left(0 ^ {n}\right)$. \\
        Conversely, if we set \begin{gather}
            m_0 = m_0'
            m_1 = m_1'
        \end{gather}
        Then we can give $\mathcal{A}'$ the input $\left(Enc_{pk} \left(0 ^ {n}\right), c^*\right)$, where $c^* = E_k
        \left(m_b\right)$, and since it has the advantage for $E_k \left(m_0'\right)$ and $E_k \left(m_1'\right)$, we
        will once again get back the correct $b'$. \\ 
        Finally, we can also have $\mathcal{A}$ output \begin{gather*}
            m_0 = 0 ^ {n} \\ 
            m_1 = k
        \end{gather*}
        Receiving back $c^* = Enc_{pk} \left(m_b\right)$, give $\left(c^*, E_k \left(m_1'\right)\right)$ to
        $\mathcal{A}'$, and thanks to the advantage that $\mathcal{A}'s$ has between $Enc_{pk} \left(0 ^ {n}\right)$ and
        $Enc_{pk} \left(k\right)$, it will return the correct $b'$.
    \end{proof}
\end{theorem}

\subsection{El-Gamal Encryption}\label{sub:el_gamal_encryption} % (fold)
Behold a real public key encryption scheme. It is based on Diffie-Hellman key agreement, and relies on the DDH
assumption. Recall the DDH assumption: Let $\mathcal{G}$ be a PPT algorithm that on input $1 ^ {n}$, outputs $\left(\G, q, g\right)$, where $\G$ is a cyclic
group of order $q$, that is generated by $g$, and $q$ is an $n$bit prime.
\begin{definition}[The Decisional Diffie Hellman (DDH) Assumption]
    For every PPT algoirithm $\mathcal{A}$ there exists a negligible function $v \left(\cdot\right)$ such that \[
        \left|\Pr \left[\mathcal{A} \left(\G, q, g, g ^ {x}, g ^ {y}, g to xz\right) = 1\right] - \Pr \left[\mathcal{A}
        \left(\G, q, g, g ^ {x}, g ^ {y}, g ^ {z}\right) = 1\right]\right| \leq v \left(n\right)
    \]
    Where $\left(\G, q, g\right) \gets \mathcal{G} \left(1 ^ {n}\right)$, and $x, y, z \gets \Z_q$
\end{definition}

So: Let $\mathcal{G}$ be a PPT algorithm that on input $1 ^ {n}$ outputs $\left(\G, q, g\right)$, where $\G$ is a cyclic
group of order $q$, that is generated by $g$. We will define a public key encryption scheme $\Pi = \left(KeyGen, Enc,
Dec\right)$ as \begin{itemize}
    \item $Gen' \left(1 ^ {n}\right)$: Sample $\left(\G, q, g\right) \gets \mathcal{G} \left(1 ^ {n}\right)$, and $x
        \gets \Z_q$. Let $h = g ^ {x}$, and output $pk = \left(\G, q, g, h\right)$, and $sk = x$
    \item $Enc_{pk} \left(m\right)$: Sample $y \gets \Z_q$, and output $c = \left(g ^ {y}, h ^ {y} \cdot m\right)$
    \item $Dec_{sk} \left(c_1, c_2\right)$: Output $m = \displaystyle\frac{c_2}{c_1 ^ {x}}$
\end{itemize}
Note that there are methods for encoding binary strings as group elements, and that for simplicity, we assume that the
plaintext set is $\G$. 
\[
    Dec_{sk} \left(Enc_{pk} \left(m\right)\right) = Dec_{sk} \left(g ^ {y}, h ^ {y} \cdot m\right) =
    \displaystyle\frac{h ^ {y} \cdot m}{\left(g ^ {y}\right) to x} = \displaystyle\frac{\left(g ^ {x}\right) ^ {y} \cdot
    m}{\left(g ^ {y}\right) ^ {x}} = m
\]

\begin{theorem}[Security]
    Under the DDH assumption, the scheme $\Pi$ is secure

    \begin{proof}[Proof ]
        Hey look! Another reduction. We will assume that there exists $\mathcal{A}$ that breaks $\Pi$, and so we can
        build $\mathcal{D}$ that breaks DDH. So, $\mathcal{D}$ receives $\left(g ^ {x}, g ^ {y}, g ^ {z}\right)$, and
        needs to return if $z = xy$, or if $z$ is random. \\ 

        Let us construct $\mathcal{D}$, that receives $\left(\G, q, g, g_1, g_2, g_3\right)$. It will give $\mathcal{A}$
        $pk = \left(\G, q, g, g_1\right)$. $\mathcal{A}$ will return $m_0, m_1$, and then $\mathcal{D}$ will return to
        $\mathcal{A}$ the ciphertext $c^* = \left(g_2, g_3 \cdot m_b\right)$. \\ 

        \textbf{Case I}: \[
            \left(g, g_1, g_2, g_3\right) = \left(g, g ^ {x}, g ^ {y}, g ^ {xy}\right)
        \]
        Here, $\mathcal{A}$'s view is identical to the CPA experiment, and therefore \[
            \Pr \left[\mathcal{D} \left(\G, q, g, g ^ {x}, g ^ {y}, g ^ {xy}\right) = 1\right] = \Pr \left[IND_{\Pi,
            \mathcal{A}}^{CPA} \left(n\right) = 1\right]
        \]

        \textbf{Case II}: Let $z$ be a random number, of appropriate size: \[
            \left(g, g_1, g_2, g_3\right) = \left(g, g ^ {x}, g ^ {y}, g ^ {z}\right)
        \]
        The view of $\mathcal{A}$ is independent of the bit $b$, and so \[
            \Pr \left[\mathcal{D} \left(\G, q, g, g ^ {x}, g ^ {y}, g ^ {z}\right) = 1\right] = \displaystyle\frac{1}{2}
        \]

        So, given $\left(\G, q, g, g_1, g_2, g_3\right)$, our algorithm $\mathcal{D}$ will generate $pk = \left(\G, q,
        g, g_1\right)$, and upon $\mathcal{A}$ response of $m_0, m_1$, it will return $c^* = \left(g_2, g_3 \cdot
        m_b\right)$. It will take $\mathcal{A}$'s output $b'$, and output 1 if $b' = b$, and 0 otherwise. By the DDH
        assumption: \begin{align*}
            v \left(n\right) &\geq \left|\Pr \left[\mathcal{D} \left(\G, q, g, g ^ {x}, g^y, g ^ {xy}\right) = 1\right] -
            \Pr \left[\mathcal{D} \left(\G, q, g, g ^ {x}, g ^ {y}, g ^ {z}\right) = 1\right]\right| \\ 
                             &= \left|\Pr \left[IND_{\Pi, \mathcal{A}}^{CPA} \left(n\right) = 1\right] -
                             \displaystyle\frac{1}{2}\right|
        \end{align*}
    \end{proof}
\end{theorem}

% subsection El-Gamal Encryption (end)


% section Hybrid encryption (end)

\section{Constructions}\label{sec:constructions} % (fold)

% section Constructions (end)

\end{document}
